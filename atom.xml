<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>icessun&#39;s Blog</title>
  <subtitle>有酒有故事</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://icessun.github.io/"/>
  <updated>2017-08-10T02:58:46.516Z</updated>
  <id>http://icessun.github.io/</id>
  
  <author>
    <name>icessun</name>
    <email>icessun@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>javaScript高级程序设计读书笔记（六）</title>
    <link href="http://icessun.github.io/javaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89.html"/>
    <id>http://icessun.github.io/javaScript高级程序设计读书笔记（六）.html</id>
    <published>2017-08-10T02:57:20.000Z</published>
    <updated>2017-08-10T02:58:46.516Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>面向对象的程序设计，面向对象的语言有类的概念，通过类创造多个具有相同的属性和方法的对象。</p>
</blockquote>
<a id="more"></a>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h4><ul>
<li>数据属性：包含一个数据值的位置，可以读取和写入<ul>
<li><code>[[Configurable]]</code>：是否可以delect删除属性</li>
<li><code>[[Enumerable]]</code>：是否可以for-in循环对象</li>
<li><code>[[Writable]]</code>：是否可以修改属性的值</li>
<li><code>[[Value]]</code>：属性的数据值</li>
</ul>
</li>
<li>访问器属性：不包含数据值，包含下面两个函数<ul>
<li><code>getter</code></li>
<li><code>setter</code></li>
</ul>
</li>
</ul>
<p>####创建对象</p>
<blockquote>
<p>以前使用的创建对象的方法（直接<code>new Object</code>和字面量），有明显的缺点：会出现大量冗余的代码。</p>
</blockquote>
<h5 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h5><blockquote>
<p> 用函数来封装以特定接口创建对象的细节，根据接收的参数来创建一个包含所有必要信息的对象。缺点是无法解决对象识别的问题，就是怎么知道一个对象的类型。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">creatPerson</span>(<span class="params">name,age,job</span>)</span>&#123;</div><div class="line">   <span class="keyword">var</span> o=<span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">// 创建一个对象</span></div><div class="line">   o.name=name;</div><div class="line">   o.age=age;</div><div class="line">   o.job=job;</div><div class="line">   o.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">       <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> o;  <span class="comment">// 返回这个创建的对象</span></div><div class="line"> &#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> preson=creatPerson(<span class="string">'icessun'</span>,<span class="number">18</span>,<span class="string">'sofeware engineer'</span>)</div></pre></td></tr></table></figure>
<h5 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h5><blockquote>
<p>Object和Array这样原生的构造函数，在运行时会自动出现在执行环境中，也可以自定义构造函数，可以直接创建对象。使用构造函数重写工厂模式代码，有以下不同：</p>
<ul>
<li>没有显示的创建对象</li>
<li>直接将属性和方法赋给<code>this</code>对象</li>
<li>没有return语句</li>
</ul>
<p>问题：每个实例都重复的创建方法，包含了不同的<code>Function</code>实例，导致不同的作用域链和标识的解析，person1和person2中的方法是不相同的。虽然可以在全局定义一个函数，然后在构造函数里面将属性设置为全局的函数，但一个全局函数只能被一个对象调用，物不能尽其所用，也没有封装可言。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.age=age;</div><div class="line">    <span class="keyword">this</span>.name=name;</div><div class="line">    <span class="keyword">this</span>.job=job;</div><div class="line">    <span class="keyword">this</span>.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">     &#125;;</div><div class="line"> &#125;</div><div class="line"> <span class="keyword">var</span> person1=<span class="keyword">new</span> Person(<span class="string">'icessun'</span>,<span class="number">18</span>,<span class="string">"software Enginner"</span>);</div><div class="line"> <span class="keyword">var</span> person2=<span class="keyword">new</span> Person(<span class="string">'icessun1'</span>,<span class="number">19</span>,<span class="string">'student'</span>);</div></pre></td></tr></table></figure>
<p>使用new方式（调用构造函数的方法）创建的对象实例， 会经历下面四步：</p>
<ul>
<li>创建一个新对象</li>
<li>将构造函数的作用域赋给新对象，this就指向这个新对象</li>
<li>执行构造函数中的代码，添加属性和方法</li>
<li>返回新对象</li>
</ul>
<p>这样的每一个实例对象身上都有一个constructor（构造函数）属性，指向Person，可以用来标识对象类型的（特定的类型）；但是检测对象类型一般使用instanceof操作符可靠一些。</p>
<h5 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h5><blockquote>
<p>创建的每一个函数都有一个prototype（原型）属性，指向一个对象；这个对象（原型对象 ）的用途是包含可以由特定类型的所有实例共享的属性和方法。prototype就是通过调用构造函数而创建的实例的原型对象。好处：可以让所有的实例共享原型对象包含的属性和方法，不用在构造函数里面定义实例的信息，而是直接添加到原型对象中。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Person.prototype.constructor------&gt; Person </div><div class="line"><span class="comment">// 空的构造函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 属性和方法都添加到Person的prototype属性中，由实例共享</span></div><div class="line">Person.prototype.name=<span class="string">"icessun"</span>;</div><div class="line">Person.prototype.age=<span class="string">"18"</span>;</div><div class="line">Person.prototype.job=<span class="string">"engineer"</span>;</div><div class="line">Person.prototype.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">     <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line"> &#125;;</div><div class="line"><span class="keyword">var</span> person1=<span class="keyword">new</span> Person(); <span class="comment">// 调用构造函数创建对象实例</span></div><div class="line">preson1.sayName(); <span class="comment">// icessun</span></div><div class="line"><span class="keyword">var</span> person2=<span class="keyword">new</span> Person();</div><div class="line">person2.sayName();<span class="comment">// icessun</span></div><div class="line"></div><div class="line"> <span class="built_in">console</span>.log(person1.sayName == person2.sayName); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<ul>
<li>理解原型对象</li>
</ul>
<blockquote>
<p>创建一个函数就会为该函数创建一个<code>prototype</code>属性，指向函数的原型对象<code>函数.Prototype</code>；所有的原型对象都自动获得一个<code>constructor</code>（构造函数）属性，这个属性包含一个指向<code>prototype</code>属性所在函数的指针。构造函数创建的实例，其内部有一个指针<code>[[Prototype]](或者)__proto__</code>，指向构造函数的原型对象，这个链接是在实例和构造函数的原型对象之间的。</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/1811036-4b8b7a5e218b66cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="原型对象和构造函数和实例对象之间的关系"></p>
<p>Person.prototype指向原型对象，而Person.prototype..constructor有指向Person。原型对象中除了包含constructor属性之外，还包括后来添加的其他属性。Person的实例都包含一个内部属性指向Person.prototype，与构造函数没有直接的关系。在所有的实现中都无法访问到[[Prototype]]，但是可以通过isPrototypeOf()方法来确定对象之间是否存在这种关系，如果[[Prototype]]指向调用isPrototypeOf()方法(ECMAScript 5中新方法：Object.getPrototypeOf())的对象（Person.prototype），那就返回true</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">console.<span class="built_in">log</span>(person.prototype.isPrototypeOf(person1)) //<span class="literal">true</span> </div><div class="line">console.<span class="built_in">log</span>(person.prototype == Object.getPrototypeOf(person1)) //<span class="literal">true</span> </div><div class="line">console.<span class="built_in">log</span>(Object.getPrototypeOf(person1).name);// icessun  Object.getPrototypeOf(person1) 直接返回<span class="string">[[Prototype]]</span>的值</div></pre></td></tr></table></figure>
<blockquote>
<p>当查找对象的属性时，现在实例找，没有找到才去原型对象上面找；可以通过实例对象访问保存在原型中的值，但是却不能通过对象实例重写原型中的值，当与原型中的属性同名的时，会自动屏蔽原型中的属性。</p>
</blockquote>
<div id="music163player"><br><br>   <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=22453837&auto=1&height=66"></iframe><br><br></div>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;面向对象的程序设计，面向对象的语言有类的概念，通过类创造多个具有相同的属性和方法的对象。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://icessun.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javascript" scheme="http://icessun.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>git与github学习笔记</title>
    <link href="http://icessun.github.io/git%E4%B8%8Egithub%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
    <id>http://icessun.github.io/git与github学习笔记.html</id>
    <published>2017-08-08T09:22:05.000Z</published>
    <updated>2017-08-09T09:16:18.029Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/1811036-ba75eec40861687e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="工作流图"></p>
<a id="more"></a>
<h2 id="认识Git"><a href="#认识Git" class="headerlink" title="认识Git"></a>认识<code>Git</code></h2><ul>
<li>是一个强大的分布式版本控制工具 </li>
<li>分布式：可以协作，任务可以拆分；每次的改动都有记录，版本可以控制</li>
<li>强大的分支管理</li>
</ul>
<h4 id="直接记录快照，而非差异比较"><a href="#直接记录快照，而非差异比较" class="headerlink" title="直接记录快照，而非差异比较"></a>直接记录快照，而非差异比较</h4><blockquote>
<p>关心文件数据的整体是否发生变化，而非文件内容的具体差异；每一次提交更新，会对所有的文件作一快照，保存一个指向快照的索引，要是文件没有变化，不会再次保存，只是对上次保存的快照作一链接。</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/1811036-37d61b88c4e7ea67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="更新的文件快照"></p>
<h4 id="几乎都是在本地操作"><a href="#几乎都是在本地操作" class="headerlink" title="几乎都是在本地操作"></a>几乎都是在本地操作</h4><blockquote>
<p> <code>Git</code>在本地磁盘上就保存着所有当前项目的历史更新，所有保存在 <code>Git</code> 数据库中的东西都是用哈希值(<code>SHA-1</code> 校验和)来作索引的，而不是靠文件名。在保存到  <code>Git</code> 之前，所有数据都要进行内容的校验和（checksum）计算，并将此结果作为数据的唯一标识和索引。</p>
</blockquote>
<h4 id="文件的三种状态"><a href="#文件的三种状态" class="headerlink" title="文件的三种状态"></a>文件的三种状态</h4><ul>
<li>已修改（本地仓库进行<code>add</code>）</li>
<li>已暂存（暂存区域<code>staging area  commit</code>）</li>
<li>已提交（<code>git</code>工作目录 ）<br>-<code>git</code>工作目录 ：用来保存元数据和对象数据库的地方。该目录非常重要，每次克隆镜像仓库的时候，实际拷贝的就是这个目录里面的数据。<ul>
<li>如果 <code>git clone</code> 出来的话，<code>Git</code> 目录就是其中<code>.git</code> 的目录；如果<code>git clone --bare</code> 的话，新建的目录本身就是<code>Git</code> 目录</li>
</ul>
</li>
</ul>
<h2 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a><code>Git</code>安装</h2><ul>
<li><p><code>windows</code>上面安装</p>
<ul>
<li>直接下载<code>msysgit</code><a href="https://git-for-windows.github.io" target="_blank" rel="external">软件</a></li>
<li>开始菜单里面找到<code>Git</code>—-&gt;<code>Git Bash</code>，或者在一个文件夹上面鼠标右键，选择<code>Git Bash</code>，出现类似命令行窗口，说明安装成功</li>
<li><p>配置</p>
   <figure class="highlight verilog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">     <span class="comment">//在命令行里面输入下面两句，进行配置</span></div><div class="line">        $ git <span class="keyword">config</span> --<span class="keyword">global</span> user<span class="variable">.name</span> <span class="string">"Your Name"</span></div><div class="line">        $ git <span class="keyword">config</span> --<span class="keyword">global</span> user<span class="variable">.email</span> <span class="string">"email@example.com"</span>     </div><div class="line"></div><div class="line"><span class="comment">// 配置差异分析工具</span></div><div class="line">$ git <span class="keyword">config</span> --<span class="keyword">global</span> merge<span class="variable">.tool</span> vimdiff</div><div class="line"></div><div class="line"> <span class="comment">// 查看git配置信息</span></div><div class="line">       $ git <span class="keyword">config</span> --list</div><div class="line"> <span class="comment">// 获取帮助</span></div><div class="line"> $ git help &lt;verb&gt;</div></pre></td></tr></table></figure>
<ul>
<li>在全局配置了用户名和<code>Email</code>地址，就是以后电脑上面的所有仓库都是使用这个配置</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><ul>
<li>使用<code>git</code>窗口创建一个文件夹</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> mkdir 文件名 //创建这个文件名</span></div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> 文件名 // 进入到这个文件名</span></div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">pwd</span>  // 查看这个文件所在的目录</span></div></pre></td></tr></table></figure>
<ul>
<li>接着初始化一个<code>Git</code>仓库</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 首先应该进入到创建的文件夹目录下</div><div class="line"><span class="meta">$</span><span class="bash"> git init</span></div><div class="line">初始化后，在当前的目录下面会出现一个.git的文件夹，所有 Git 需要的数据和资源都存放在这个文件夹中</div><div class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> url // 默认是克隆下来的项目名字的文件夹作为项目的文件夹</span></div><div class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> url 自定义文件夹名字  // 使用自己自定义的文件夹作为项目目录的文件夹</span></div></pre></td></tr></table></figure>
<blockquote>
<p>版本库初始化之后，就在本地默认创建了<strong>主分支</strong> <code>master</code>，用来发布重大的版本，日常开发在这个主分支上面开辟一条<strong>开发分支</strong>来操作，然后合并到主分支上面</p>
</blockquote>
<ul>
<li>当然也可以直接在你想在的目录下面（确保这个目录下面没有中文，否则出错），鼠标右键新建一个文件夹，然后鼠标右键选择<code>Git　Bash</code>，输入<code>git　init</code></li>
</ul>
<h2 id="文件保存在仓库"><a href="#文件保存在仓库" class="headerlink" title="文件保存在仓库"></a>文件保存在仓库</h2><ul>
<li>然后把我们需要保存在仓库的文件，直接拖到我们刚才创建的仓库的文件夹下，然后打开<code>Git</code>命令窗口，输入下面的命令，使里面的文件纳入到版本控制，进行跟踪</li>
</ul>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">$</span> git add &lt;<span class="keyword">file</span>&gt;  <span class="comment">// 把文件添加到仓库 暂存区</span></div><div class="line"><span class="symbol">$</span> git commit -m <span class="string">'描述'</span>  <span class="comment">// 文件提交到仓库 保存一个版本的快照 保存在版本历史记录里面</span></div><div class="line"></div><div class="line"><span class="symbol">$</span> git commit -a -m <span class="string">'描述'</span> <span class="comment">// 直接跳过暂存区，把所有已经跟踪过的文件暂存起来一起提交</span></div><div class="line"></div><div class="line"><span class="comment">// 漏掉的文件没有加入，或者提交的消息写错了 修改最后一次提交 如果刚才提交完没有作任何改动，直接运行此命令的话，相当于有机会重新编辑提交说明，但将要提交的文件快照和之前的一样。</span></div><div class="line"><span class="symbol">$</span> git commit --amend </div><div class="line"></div><div class="line"></div><div class="line"><span class="symbol">$</span> git rm 要删除的文件 <span class="comment">// 该文件就不会纳入版本管理，要是这个删除文件，已经修改并且放到了暂存区的话，就必须强制删除 -f</span></div><div class="line"></div><div class="line"><span class="symbol">$</span> git rm --cached 不跟踪的文件 <span class="comment">// 把文件从跟踪清单里面删除</span></div><div class="line"></div><div class="line"><span class="comment">// 重新命名文件</span></div><div class="line"><span class="symbol">$</span> git mv file_from  file_to</div></pre></td></tr></table></figure>
<ul>
<li>当然可以使用<code>$ git add *</code>来提交所有的文件</li>
<li>当我们更改了文件，使用<code>$ git status</code>可以查看我们更改的那个文件，这个命令是让我们时刻了解当前仓库的状态，以及那些文件被添加到了暂存区，那些文件没有被添加<ul>
<li>可以使用<code>$ git diff</code>来查看具体修改了什么地方，是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容，若要看已经暂存起来的文件和上次提交时的快照之间的差异，可以用<code>git diff --cached</code> 命令。更高版本还允许使用<code>git diff --staged</code>，效果是相同的，但更好记些。</li>
<li>要把修改后的文件，提交到仓库，继续上面的两个命令<code>add 和 commit</code></li>
<li>此时在运行<code>$ git status</code>，就会提示，当前没有需要提交的修改，工作目录干净<code>working directory clean</code></li>
</ul>
</li>
</ul>
<h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><ul>
<li><code>commit</code>命令是在仓库里面保存我们一个版本的快照，所有后面跟的说明文件很重要，我们可以使用<code>$ git log</code>来查看我们保存的版本历史记录，通过描述文件更快的知道，然后通过历史记录回退到以前的版本</li>
</ul>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">$</span> git <span class="built-in">log</span> <span class="comment">// 从最近的到最远的版本记录</span></div><div class="line"> </div><div class="line"><span class="symbol">$</span> git <span class="built-in">log</span> -p <span class="number">-2</span> <span class="comment">// -p 展示每次提交的内容差异 -2 最近两条 </span></div><div class="line"></div><div class="line"><span class="symbol">$</span> git <span class="built-in">log</span> --pretty=oneline  --graph <span class="comment">// 输出的信息更简短   --graph  多出一些 ASCII 字符串表示的简单图形，形象地展示了每个提交所在的分支及其分化衍合情况。</span></div></pre></td></tr></table></figure>
<ul>
<li>此时我们可以从输出的信息看到<code>commit id</code> ，是一连串的由<code>sha1</code>计算出来并且以16进制表示的数字，这个数字是我们回退到以前版本的版本号</li>
<li>在<code>git</code>中，使用<code>HEAD</code>表示当前版本，也就是上面输出信息的第一个，上一个版本就是<code>HEAD^</code>，上上个版本就是<code>HEAD^^</code>，以此类推，n个前的版本就是<code>HEAD~n</code></li>
<li>回退到上一个版本，使用下面命令，然后输出<code>HEAD is now at commit id号 说明信息</code>，查看仓库的文件，已经恢复到上一个版本了</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> git reset --hard HEAD^</span></div></pre></td></tr></table></figure>
<ul>
<li>此时在次输入<code>$　git　log</code>，我们会发现，前一个版本不见了，只有我们现在的版本和现在版本之前的版本，要是我们还是需要回到前一个版本呢，这个时候<code>commit id</code>就发挥作用了，在当前的窗口向上查找前一个版本的<code>commit id</code>号，然后输入<code>$ git reset --hard commit id号，不需要输入完整的</code></li>
<li>当我们不小心关闭了窗口，找不到了前一个版本的id的时候，我们可以使用<code>$ git reflog</code>来查找，查看命令历史</li>
</ul>
<h2 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h2><h3 id="工作区"><a href="#工作区" class="headerlink" title="工作区"></a>工作区</h3><ul>
<li>就是我们创建的仓库</li>
</ul>
<h3 id="版本库"><a href="#版本库" class="headerlink" title="版本库"></a>版本库</h3><ul>
<li>在工作区里面隐藏了一个<code>.git</code>文件，这个是版本库</li>
<li>版本库里面有暂存区<code>stage</code>，还有自动创建的第一个分支<code>master</code>，以及指向这个分支的指针<code>HEAD</code></li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1811036-6cb8ec5cf370a38b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="git add 工作"></p>
<ul>
<li>前面说道通过<code>add 和 commit -m</code>把文件添加到版本库里面</li>
</ul>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">$</span> git add  * <span class="comment">//把修改的文件添加到暂存区</span></div><div class="line"><span class="symbol">$</span> git commit -m <span class="comment">// 把暂存区的内容提交到当前的分支（master），没有创建其他分支的情况下</span></div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/1811036-c1ab7fa3fdc5a116.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="git commit 工作"></p>
<ul>
<li>如果不<code>add</code>到暂存区，那就不会加入到<code>commit</code>中</li>
<li><code>Git</code>管理的是修改，而不是文件；也就是说，每一次修改的时候，都要先<code>add</code>，然后在<code>commit</code></li>
</ul>
<h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><blockquote>
<p>什么时候会出现修改撤销呢？我们在工作区修改文件错误；或者已经<code>add</code>提交了，把错误也提交了暂存区；在或者<code>commit</code>把错误提交到了版本库</p>
</blockquote>
<h3 id="在工作区撤销修改，没有add之前"><a href="#在工作区撤销修改，没有add之前" class="headerlink" title="在工作区撤销修改，没有add之前"></a>在工作区撤销修改，没有<code>add</code>之前</h3><ul>
<li>发现错误及时，可以直接手动把错误删除</li>
<li>要是错误太多，也可以使用命令<code>$ git checkout -- &lt;file&gt;</code>，来撤销修改，丢弃工作区的修改</li>
</ul>
<h3 id="add之后，commit之前"><a href="#add之后，commit之前" class="headerlink" title="add之后，commit之前"></a><code>add</code>之后，<code>commit</code>之前</h3><ul>
<li>取消已经暂存的文件，回到已经修改但未暂存的文件</li>
<li>这个时候，使用这个命令，可以撤销暂存区的修改，重新放回到工作区<code>$ git reset HEAD &lt;file&gt;</code></li>
<li>退回到工作区，我们接着可以使用<code>$git checkout -- &lt;file&gt;</code>来撤销工作区的修改</li>
</ul>
<h3 id="commit之后，提交到了版本库，没有推送到远程"><a href="#commit之后，提交到了版本库，没有推送到远程" class="headerlink" title="commit之后，提交到了版本库，没有推送到远程"></a><code>commit</code>之后，提交到了版本库，没有推送到远程</h3><ul>
<li>这个时候，我们只能<strong>回退版本</strong>了，前提是你没有把版本库提交到远程，否则是修改不了了</li>
</ul>
<h3 id="远程仓库github"><a href="#远程仓库github" class="headerlink" title="远程仓库github"></a>远程仓库<code>github</code></h3><ul>
<li>访问<a href="https://github.com/" target="_blank" rel="external">github</a>官网注册帐号，参考<a href="https://guides.github.com/activities/hello-world/" target="_blank" rel="external">资料</a></li>
<li>由于本地仓库和远程仓库是靠<code>ssh</code>加密传输的，所以首先要创建<code>SSH KEY</code>，打开用户主目录，一般是这样的地址<code>C:\Documents and Settings\Administrator</code>，查看是否有一个<code>.ssh</code>的文件，可能文件夹被隐藏，应该在文件夹选项里面设置显示隐藏文件，有的话，直接打开，复制<code>id_rsa.pub（公钥）</code>里面的内容，登入<code>github</code>网站，打开<code>account settings</code>，选择<code>SSH KEYS</code>页面，然后点击<code>Add SSH KEY</code>，把复制的内容粘贴到里面就行</li>
<li>要是主目录下面没有，打开<code>git</code>命令窗口，创建SSK KEY；<code>$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code></li>
<li>然后在远程仓库里面创建一个仓库，在本地仓库里面使用下面命令和远程仓库建立链接：<code>$ git remote add origin git@github.com:icessun/icessun.github.io.git // 添加远程仓库</code>，远程库的名字默认<code>origin</code></li>
<li>推送本地仓库的文件到远程库中</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> git push origin master / 远程仓库的名字  分支的名字</span></div><div class="line"><span class="meta">$</span><span class="bash"> git remote show 远程仓库的名字 // 查看远程仓库的信息</span></div><div class="line"><span class="meta">$</span><span class="bash"> git remote rename 原远程仓库的名字  现在仓库的名字 // 修改某个远程仓库在本地的简称</span></div><div class="line"><span class="meta">$</span><span class="bash"> git remote rm 远程仓库的名字  // 碰到远端仓库服务器迁移，或者原来的克隆镜像不再使用，又或者某个参与者不再贡献代码，那么需要移除对应的远端仓库，</span></div></pre></td></tr></table></figure>
<ul>
<li>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。以后每次提交只需要<code>$ git push origin master</code></li>
</ul>
<ul>
<li>查看当前配置了那些远程仓库</li>
</ul>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">$</span> git remote <span class="comment">// 查看配置了那些远程仓库</span></div><div class="line"></div><div class="line"><span class="symbol">$</span> git remote -v <span class="comment">// 显示对应的克隆地址  </span></div><div class="line"></div><div class="line"><span class="comment">// 如果是克隆了一个仓库，此命令会自动将远程仓库归于 origin 名下。 </span></div><div class="line"><span class="symbol">$</span> git fetch origin  <span class="comment">// 会抓取从你上次克隆以来别人上传到此远程仓库中的所有更新（或是上次 fetch 以来别人提交的更新）</span></div><div class="line"></div><div class="line"><span class="symbol">$</span> git fetch 远程仓库名 <span class="comment">// 拉取本地仓库没有的信息 从远程仓库抓取数据到本地 并不自动合并到当前工作分支</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>克隆远程仓库</strong><code>$ git clone git@github.com:icessun/icessun.github.io.git</code></li>
</ul>
<blockquote>
<p><code>git clone</code> 命令本质上就是自动创建了本地的 <code>master</code>分支用于跟踪远程仓库中的 <code>master</code> 分支；运行 <code>git pull</code>，目的都是要从原始克隆的远端仓库中抓取数据后，合并到工作目录中的当前分支。</p>
</blockquote>
<h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><blockquote>
<p>使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作；切换分支之前要保存当前分支的工作区是干净的，把修改提交，否则不让你切换分支</p>
</blockquote>
<ul>
<li>创建分支：<code>$ git branch 分支的名字</code></li>
<li>切换分支：<code>$ git checkout 分支的名字</code><figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 上面两个命令合并成为一条</span></div><div class="line"> <span class="symbol">$</span> git checkout -b 分支的名字</div><div class="line"></div><div class="line"> <span class="symbol">$</span> git branch -v <span class="comment">// 查看各个分支最后一个提交对象的信息</span></div><div class="line"> </div><div class="line"> <span class="symbol">$</span> git branch --merged <span class="comment">// 查看哪些分支已被并入当前分支，也就是说哪些分支是当前分支的直接上游。</span></div><div class="line"></div><div class="line">  <span class="symbol">$</span> git branch --<span class="keyword">no</span>-merged <span class="comment">// 查看尚未合并的工作</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1811036-cf10ad8782bbf5dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建分支testing"></p>
<p><code>HEAD</code>指向当前工作的分支，也可以说是当前分支的别名，<code>HEAD</code>会随着当前工作分支的变化而变化，每提交一次，<code>HEAD</code>向前走动一次</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1811036-c7cbd04c0d0c6675.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="切换到新建的分支上面"></p>
<p>在当前新建的分支上面提交后，会向前移动了一格，而<code>master</code>分支仍然指向原先 <code>git checkout</code>时所在的 <code>commit</code> 对象。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1811036-d8be59b377236c97.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在新建的分支上面提交"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1811036-f772fd796b75f803.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="切换到主分支上面"></p>
<p>在当前分支上面再次提交，项目提交历史产生了分叉；因为刚才我们创建了一个分支，转换到其中进行了一些工作，然后又回到原来的主分支进行了另外一些工作。这些改变分别孤立在不同的分支里：我们可以在不同分支里反复切换，并在时机成熟时把它们合并到一起。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1811036-a2184c59fda15d32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="项目提交历史出现分叉"></p>
<ul>
<li>查看当前的分支：<code>$ git branch</code>，当前的分支会出现一个<code>*</code>号</li>
<li>把当前分支合并到主分支上面：<code>$ git merge 要合并的分支</code>，合并到<code>master</code>分支上面，合并分支前要切换到要合并的分支上面</li>
</ul>
<p>由于当前 master 分支所指向的提交对象<code>（C4）</code>并不是 <code>iss53</code>分支的直接祖先，Git 不得不进行一些额外处理。就此例而言，Git 会用两个分支的末端<code>（C4 和 C5）</code>以及它们的共同祖先<code>（C2）</code>进行一次简单的三方合并计算。用红框标出了<code>Git</code>用于合并的三个提交对象：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1811036-a895f2357b36eac1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="分支的合并"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1811036-7355bcfa08d7aa04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="合并后"></p>
<h4 id="合并出现冲突"><a href="#合并出现冲突" class="headerlink" title="合并出现冲突"></a>合并出现冲突</h4><ul>
<li>如果在不同的分支中都修改了同一个文件的同一部分，Git 就无法干净地把两者合到一起（译注：逻辑上说，这种问题只能由人来裁决。）<ul>
<li>要看看哪些文件在合并时发生冲突，可以用 git status 查阅</li>
</ul>
</li>
</ul>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="code"> &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span></div><div class="line"><span class="section">&lt;div id="footer"&gt;contact : email.support@github.com&lt;/div&gt;</span></div><div class="line">=======</div><div class="line">&lt;div id="footer"&gt;</div><div class="line"><span class="code">  please contact us at support@github.com</span></div><div class="line">&lt;/div&gt;</div><div class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53</div></pre></td></tr></table></figure>
<p>可以看到<code>=======</code>隔开的上半部分，是 <code>HEAD</code>（即 <code>master</code>分支，在运行<code>merge</code> 命令时所切换到的分支）中的内容，下半部分是在 <code>iss53</code>分支中的内容。</p>
<ul>
<li>删除分支：<code>$ git branch -d 要删除的分支的名字</code></li>
<li>分支合并出现冲突：<code>$ git log --graph --pretty=oneline --abbrev-commit</code>查看分支合并的情况，出现冲突的时候，我们应该手动修改冲突，在提交</li>
<li>合并禁止<code>Fast forward（当前要合并的分支[新]是master分支[老]的直接上游）</code>模式：<code>$ git merge --no-ff -m &#39;描述&#39; 要合并的分支</code>；这样可以保存合并的分支</li>
<li><code>Bug</code>分支：把当前的工作现场隐藏起来：<code>$ git stash</code>；接着和创建分支一样，创建一个临时的bug分支，修改完成之后合并bug分支到master主分支上面，<code>$ git stash list</code>；查看当前的工作区的隐藏列表，恢复工作区：<code>$ git stash pop</code>，继续工作区的任务</li>
<li>每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支；如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -d &lt;分支name&gt;强行删除</code></li>
</ul>
<h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><ul>
<li>在本地克隆远程仓库的时候，自动把本地的master分支和远程的master分支对应起来</li>
<li>查看远程仓库的信息<code>$ git remove -v</code>：就会显示抓取（fetch）和推送（push）的<code>origin（远程仓库默认的名字）</code>地址，没有推送权限是看不到（push）地址</li>
<li>推送分支（把该分支上的所有本地提交推送到远程仓库）：<code>$ git push origin 本地分支的名字</code></li>
<li>当你小伙伴把修改的推送到了远程，而你正好也修改了相同的文件，那么你就必须<code>git pull</code>下来最新的添加，在本地解决冲突合并，在推送到远程，如果<code>pull</code> 下来提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream 本地分支的名字 远程仓库分支的名字。</code></li>
<li>在本地创建和远程分支对应的分支，使用  <code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</li>
</ul>
<h3 id="小窍门"><a href="#小窍门" class="headerlink" title="小窍门"></a>小窍门</h3><p>在 Windows 上安装了<code>msysGit</code>，默认使用的<code>Git Bash</code>就已经配好了这个自动补全脚本，可以直接使用。</p>
<p>在输入<code>Git</code>命令的时候可以敲两次跳格键（Tab），就会看到列出所有匹配的可用命令建议：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git <span class="keyword">co</span><span class="symbol">&lt;tab&gt;</span><span class="symbol">&lt;tab&gt;</span></div><div class="line">commit   config</div></pre></td></tr></table></figure>
<ul>
<li><code>GIT</code>命名别名</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git <span class="keyword">config</span> --<span class="keyword">global</span> <span class="keyword">alias</span><span class="variable">.co</span> checkout</div><div class="line">$ git <span class="keyword">config</span> --<span class="keyword">global</span> <span class="keyword">alias</span><span class="variable">.br</span> branch</div><div class="line">$ git <span class="keyword">config</span> --<span class="keyword">global</span> <span class="keyword">alias</span><span class="variable">.ci</span> commit</div><div class="line">$ git <span class="keyword">config</span> --<span class="keyword">global</span> <span class="keyword">alias</span><span class="variable">.st</span> status</div><div class="line">$ git <span class="keyword">config</span> --<span class="keyword">global</span> <span class="keyword">alias</span><span class="variable">.last</span> 'log -<span class="number">1</span> HEAD' <span class="comment">// 要看最后一次的提交信息 git last</span></div></pre></td></tr></table></figure>
<p>现在，如果要输入 <code>git commit</code>只需键入 <code>git ci</code> 即可</p>
<blockquote>
<p>参考资料<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰网站git教程</a><br><a href="http://iissnan.com/progit/html/zh/ch2_5.html" target="_blank" rel="external">git pro</a></p>
</blockquote>
<div id="music163player"><br><br>   <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=22453837&auto=1&height=66"></iframe><br><br></div>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1811036-ba75eec40861687e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;工作流图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://icessun.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="git" scheme="http://icessun.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://icessun.github.io/hello-world.html"/>
    <id>http://icessun.github.io/hello-world.html</id>
    <published>2017-08-07T07:12:42.142Z</published>
    <updated>2017-08-03T09:12:29.150Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h1><p>Welcome to <a href="https://icessun.github.io/">icessun</a></p>
<a id="more"></a>
<div id="music163player"><br><br> <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=22453837&auto=1&height=66"></iframe><br></div>



]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;hello-world&quot;&gt;&lt;a href=&quot;#hello-world&quot; class=&quot;headerlink&quot; title=&quot;hello world&quot;&gt;&lt;/a&gt;hello world&lt;/h1&gt;&lt;p&gt;Welcome to &lt;a href=&quot;https://icessun.github.io/&quot;&gt;icessun&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>javascript高级程序设计读书笔记（四）</title>
    <link href="http://icessun.github.io/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89.html"/>
    <id>http://icessun.github.io/javascript高级程序设计读书笔记（四）.html</id>
    <published>2017-08-03T02:20:38.000Z</published>
    <updated>2017-08-03T09:15:51.792Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>  变量，作用域，和内存的问题</p>
</blockquote>
<a id="more"></a>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><blockquote>
<p>不存在定义一个变量就保存这种数据类型的值的规则，一个变量的值和数据类型可以在脚本的生命周期内改变。</p>
<ul>
<li>基本类型的值</li>
<li>引用类型的值</li>
</ul>
</blockquote>
<h4 id="基本类型的值"><a href="#基本类型的值" class="headerlink" title="基本类型的值"></a>基本类型的值</h4><blockquote>
<p>基本数据类型是<strong>按照值访问的</strong>，可以操作保存在变量里面实际的值</p>
</blockquote>
<ul>
<li>字符串</li>
<li>数值<ul>
<li><code>NaN</code>：特殊的数值型；<code>isNaN()</code>：返回是否是不是数值</li>
<li><code>isNaN()</code>被对象调用的时候，会首先调用对象的<code>valueOf()</code>，看其是否可以转为数值；不能，则基于这个返回值在调用<code>toString()</code>，再看是否是数值</li>
</ul>
</li>
<li>布尔值</li>
<li><code>undefined</code></li>
<li><code>null</code><ul>
<li>只要意在保存的变量还没有真正保存对象，就应该明确的让该变量保存<code>null</code>，体现出<code>null</code>是空对象指针。</li>
</ul>
</li>
</ul>
<blockquote>
<p>字符串，数值和布尔值都有<code>toString()</code>方法，但<code>undefined</code>和<code>null</code>没有此方法，但是可以使用<code>String()</code>，这个方法可以传入<code>基数</code>，输出二进制或者八进制或者十六进制的字符串值</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">转为true的值</th>
<th style="text-align:center">转为false的值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Boolean</td>
<td style="text-align:center">true</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:center">Number</td>
<td style="text-align:center">任何非0数字，包括无穷大</td>
<td style="text-align:center">0和NaN</td>
</tr>
<tr>
<td style="text-align:center">String</td>
<td style="text-align:center">任何非空字符串</td>
<td style="text-align:center">‘ ‘(空字符串)</td>
</tr>
<tr>
<td style="text-align:center">Object</td>
<td style="text-align:center">任何对象</td>
<td style="text-align:center">null</td>
</tr>
<tr>
<td style="text-align:center">Undefined</td>
<td style="text-align:center">不适用</td>
<td style="text-align:center">undefined</td>
</tr>
</tbody>
</table>
<p>在内存中占据固定大小的空间，因此保存在<code>栈内存</code>里面</p>
<h4 id="引用类型的值"><a href="#引用类型的值" class="headerlink" title="引用类型的值"></a>引用类型的值</h4><blockquote>
<p>是保存在内存中的对象，是<strong>按照引用来访问</strong>的，因为，<code>JS</code>是不允许直接访问内存中的位置，也就不能直接操作对象的内存空间，实际上是操作对象的引用 </p>
</blockquote>
<p>引用类型的值是对象，保存在<code>堆内存</code>中</p>
<ul>
<li><code>Object类型</code><blockquote>
<p>对象其实就是数据和功能的集合，<code>Object类型</code>是所有它的实例的基础，其所具有的任何的属性和方法同样都存在更具体的对象中。</p>
</blockquote>
</li>
</ul>
<h4 id="两种值的不同点"><a href="#两种值的不同点" class="headerlink" title="两种值的不同点"></a>两种值的不同点</h4><ul>
<li>当定义一个引用类型的变量，可以为其动态的添加属性和方法，但是基本类型的变量就不可以，虽然操作是不会出现错误，返回<code>undefined</code></li>
<li><p>基本类型的变量的复制</p>
  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var <span class="attribute">num1</span>=5;</div><div class="line">var <span class="attribute">num1</span>=num2;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>num1和num2是<strong>相互独立</strong>的，互不影响，在内存空间里面分配不同的空间</li>
</ul>
<ul>
<li><p>引用类型值的复制：</p>
  <figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1=<span class="keyword">new</span> <span class="type">Person</span>();</div><div class="line"><span class="keyword">var</span> obj2=obj1;</div></pre></td></tr></table></figure>
</li>
<li><p>此时的obj2和obj1是指向同一个地址空间，之间的复制是把引用，也就是指向这个对象的内存空间的<strong>指针复制</strong>了一份，当操作obj1的属性的时候，obj2也受到影响</p>
</li>
</ul>
<h4 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h4><blockquote>
<p><code>ECMAScript</code>中所有函数的参数都是<code>按值传递</code>的。就是把值，从外部的变量，复制一份给函数中参数变量。传递基本类型的值给函数中的参数的时候，被传递的值被复制给函数参数<code>aguments</code>对象的一个元素，局部变量；给参数传递引用类型的时候，就是把这个值在内存中的地址复制给<code>arguments</code>中的一个局部变量，所以这个局部变量变化会反映在函数的外部。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">       obj.name=<span class="string">'icessun'</span>;</div><div class="line">       obj=<span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">       obj.name=<span class="string">'icessun1'</span>;  <span class="comment">//将新的对象赋值给obj对象并设置name属性 </span></div><div class="line">  &#125; </div><div class="line">  <span class="keyword">var</span> person=<span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">  setName(person);</div><div class="line">  alert(person.name);   <span class="comment">// 弹出icessun  这说明参数的传递是按照值来的</span></div></pre></td></tr></table></figure>
<p>上面的代码说明，参数是按照值传递的，因为在函数<code>setName</code>中，重新赋值一个对象给<code>obj</code>，并且改变了其<code>name</code>属性，要是按照引用传递的话，那么后面弹出来的是<code>icessun1</code>；结果却不是这样，这说明：</p>
<blockquote>
<p>函数内部改变了参数的值，但是原始的引用保持不变；因为在函数内部重写参数时，这个变量引用就是一个局部变量，会在函数执行完毕立即销毁。</p>
</blockquote>
<h4 id="类型检测"><a href="#类型检测" class="headerlink" title="类型检测"></a>类型检测</h4><ul>
<li><code>typeof</code><ul>
<li>字符串  ——&gt;    <code>string</code><br><code>var n; console.log(typeof n); // undefined</code></li>
<li>数值   ——-&gt;  <code>number</code></li>
<li>布尔值  ——–&gt; <code>boolean</code></li>
<li><code>undefined</code> ——-&gt; <code>undefined</code></li>
</ul>
</li>
</ul>
<p><code>unll == undefined;      true</code></p>
<blockquote>
<p><code>typeof</code>是检测上面这几种类型的最佳工具，但是对于<code>null</code>和<code>对象</code>都返回<code>object</code>，因为<code>null</code>表示一个空对象指针，所以<code>typeof null</code>为<code>Object</code>；检测函数的时候，会返回<code>function</code>；这是区分函数和其他对象的方法，函数是一个对象，不是一种数据类型。</p>
</blockquote>
<p>对于未声明的变量和为初始化的变量，执行<code>typeof</code>操作都返回<code>undefined</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message; <span class="comment">//  未初始化</span></div><div class="line"><span class="comment">// var age;   未声明</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> message);  <span class="comment">// undefined</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> age);     <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<ul>
<li><code>instanceof</code> ：检测什么类型的对象（引用类型）</li>
</ul>
<blockquote>
<p><code>variable instanceof constructor</code>  返回<code>true/false</code> </p>
</blockquote>
<ul>
<li><code>Object</code></li>
<li><code>Array</code></li>
<li><code>RegExp</code><br>如果变量是给定引用类型的实例，那么<code>instanceof</code>之后返回的结果都是<code>true</code>；基本类型不是对象，都返回<code>false</code>。所有的引用类型的值都是<code>Object</code>的实例。</li>
</ul>
<h4 id="执行环境和作用域"><a href="#执行环境和作用域" class="headerlink" title="执行环境和作用域"></a>执行环境和作用域</h4><blockquote>
<p>执行环境定义了变量和函数有权访问的其他数据。决定了各自的行为。某个执行环境中的所有代码执行完毕，该环境就被销毁，保存在里面的所有的变量和函数定义也随之销毁。每个函数都有自己的执行环境，当执行这个函数的时候，会把这个函数推入到一个环境栈里面，直到函数执行完成，再从环境栈里面弹出，交到之前的执行环境。</p>
</blockquote>
<ul>
<li>作用域链<ul>
<li>保证对执行环境有权访问的所有变量和函数的有序访问；其前端，始终是当前执行代码的所在环境的变量对象<code>环境是函数，则这个活动对象就是arguments对象</code>。下一个变量对象来自包含环境（包含当前变量对象的外部环境），就这样一直延续到全局执行环境，故全局的执行环境是作用域链的最后一个对象。</li>
</ul>
</li>
</ul>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="built_in">color</span>=<span class="string">'blue'</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">color</span>===<span class="string">'blue'</span>)&#123;</div><div class="line">         <span class="built_in">color</span>=<span class="string">'red'</span>;</div><div class="line">     &#125;<span class="title">else</span>&#123;</div><div class="line">         <span class="built_in">color</span>=<span class="string">'blue'</span>;</div><div class="line">      &#125;</div><div class="line"> &#125;</div><div class="line"> changeColor();</div><div class="line"> <span class="built_in">console</span>.log(<span class="string">'Color is now'</span>+<span class="built_in">color</span>);</div></pre></td></tr></table></figure>
<p>上面的代码中，函数的作用域链包含两个对象：自己的变量对象<code>arguments对象</code>和全局环境的变量对象。可以在函数内部访问到全局的变量，因为在其的作用域链上面可以找到。<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">作用域链： </div><div class="line">    -<span class="ruby"> window</span></div><div class="line">       -<span class="ruby"> color</span></div><div class="line">       -<span class="ruby"> changeColor()</span></div><div class="line">          -<span class="ruby"> arguments</span></div></pre></td></tr></table></figure></p>
<p>  每一个环境都可以向上搜索作用域链，查询变量和函数名，但是不能向下搜索作用域链；函数参数也是函数执行环境中内部的变量，局部变量。</p>
<ul>
<li><p>延长作用域链</p>
<ul>
<li><code>try-catch语句</code>中的<code>catch块</code></li>
<li><code>with语句</code></li>
</ul>
</li>
<li><p><code>没有块级作用域</code></p>
<blockquote>
<p>在其他的类<code>C</code>语言，由花括号封闭的代码块都有自己的作用域，因而支持根据条件来定义变量。但是<code>JavaScript</code>没有块级作用域</p>
</blockquote>
<ul>
<li><p>声明变量</p>
<blockquote>
<p>使用<code>var</code>声明的变量会自动添加到<code>最接近的环境中</code>：在函数内部，最接近的就是函数的局部环境；在<code>with</code>语句中，最接近的是函数环境；如果初始化变量时没有使用<code>var</code>，则会自动把该变量添加到全局环境中。</p>
</blockquote>
<ul>
<li><strong>注意</strong>：<br>在<code>javascript</code>中，由<code>for</code>语句创建的变量<code>i</code>（由<code>var</code>声明的），即使循环结束，也依旧存在循环外部的执行环境中。</li>
</ul>
</li>
<li><p>作用域向上搜索</p>
<p>在执行环境中查找一个变量的时候，在局部环境里面找到，就直接使用；否者，继续向上的作用域链查找，没有找到，说明该变量没有声明。</p>
</li>
</ul>
</li>
</ul>
<h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><blockquote>
<p><code>javascript</code>中有自动垃圾回收机制；原理就是：找到那些不再需要继续使用的变量，然后释放其占用的内存。垃圾回收机制会按照固定的时间间隔，周期性的去执行这一操作。</p>
</blockquote>
<ul>
<li>标记清除<br> 给存储在内存中的变量都加上标记，然后去掉环境中的变量标记以及被环境中的变量引用的变量的标记；之后再加上的标记的变量是当做准备删除的变量，因为环境中的变量已经无法访问到这些变量了；最后，垃圾回收器完成垃圾的回收。</li>
<li>计数清除<br>  记录每一个值被引用的次数，当声明了一个变量并将一个引用类型赋值给该变量的时候，引用次数为1，如果同一个值又被赋给其他的变量，该值引用次数就加1，包含对这个值引用的变量又取得另外一个值，则这个值的引用次数减1，当次数为0的时候就说明不能访问到，应该回收；<strong>坏结果</strong>：循环引用。</li>
</ul>
<p><code>IE9</code>把<code>BOM</code>和<code>DOM</code>对象都转换成真正的<code>JavaScript</code>对象。就避免了垃圾回收的问题，也消除了常见的内存泄漏现象。</p>
<p>一般来说：一旦数据不再使用，最好手动将其设置为<code>null</code>，来释放其引用，适合大多数的全局变量和全局对象的属性。局部变量会在离开执行环境的时候自动解除引用。解除引用，是让值脱离执行环境，等待垃圾回收运行将其回收。</p>
<div id="music163player"><br>   <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=22453837&auto=1&height=66"></iframe><br><br></div>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;  变量，作用域，和内存的问题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://icessun.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javascript" scheme="http://icessun.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript高级程序设计读书笔记（五）</title>
    <link href="http://icessun.github.io/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89.html"/>
    <id>http://icessun.github.io/javascript高级程序设计读书笔记（五）.html</id>
    <published>2017-08-03T02:20:13.000Z</published>
    <updated>2017-08-04T03:21:29.879Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>  引用类型</p>
</blockquote>
<p>对象是某个特定的引用类型的实例。新对象是使用<code>new</code>操作符后跟一个构造函数来创建的。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> preson=<span class="keyword">new</span> <span class="built_in">Object</span>();</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a><code>Object</code>类型</h3><ul>
<li><p>创建对象的方法</p>
<ul>
<li><code>new</code>+构造函数 ：<code>var preson=new Object()</code></li>
<li><p>对象字面量 ：向函数传递大量<code>可选参数</code>的首选方式</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var <span class="keyword">person</span>=&#123;</div><div class="line">           name:'icessun',    &lt;=====&gt;var <span class="keyword">person</span>=&#123; &#125;;</div><div class="line">           age:18</div><div class="line">   &#125;</div><div class="line"></div><div class="line">访问对象的属性：<span class="keyword">person</span>.属性；<span class="keyword">person</span><span class="comment">[属性]</span>，【】一般是通过变量来访问属性</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="Array类型"><a href="#Array类型" class="headerlink" title="Array类型"></a><code>Array</code>类型</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors=<span class="keyword">new</span> <span class="type">Array</span>();  里面可以写入一个数值，表示数组的长度<span class="keyword">new</span> <span class="type">Array</span>(<span class="number">20</span>)；也可以直接在里面写入数组的值<span class="keyword">new</span> <span class="type">Array</span>(<span class="string">'red'</span>,<span class="string">'blue'</span>,<span class="string">'green'</span>)</div><div class="line"></div><div class="line">字面量方式：</div><div class="line"><span class="keyword">var</span> colors=[<span class="string">'red'</span>,<span class="string">'blue'</span>,<span class="string">'green'</span>]  <span class="comment">//不会调用Array的构造函数</span></div></pre></td></tr></table></figure>
<ul>
<li><p>检测数组</p>
<ul>
<li><code>instanceof</code><ul>
<li>是在单一的全局执行环境中检测数组，对于从一个执行环境中传递到另一个执行环境中的数组是检测不出来的</li>
</ul>
</li>
<li><code>Array.isArray()</code><ul>
<li>这个方法确定某个值到底是不是数组，而不管是在哪个全局执行环境创建的</li>
</ul>
</li>
</ul>
</li>
<li><p>转换方法</p>
<blockquote>
<p>所有的对象都具有<code>toLocaleString(),toString(),valueOf()</code></p>
</blockquote>
<ul>
<li><code>toString()</code>：默认是用<code>逗号</code>隔开返回数组的每个值的字符串</li>
<li><code>join([分隔符])</code>：使用不同的分隔符来返回数组每个值的字符串</li>
</ul>
</li>
<li><p>数组中的栈方法</p>
<blockquote>
<p>后进先出(LIFO)的数据结构，栈中项的插入和删除只发生在—-栈的顶部。</p>
</blockquote>
<ul>
<li><code>push()</code><ul>
<li>传入要在数组末尾添加的数据，返回修改后数组的长度</li>
</ul>
</li>
<li><code>pop()</code><ul>
<li>删除数组末尾的最后一项（取得数组中的最后一项），返回被删除的项</li>
</ul>
</li>
</ul>
</li>
<li><p>数组中的队列方法</p>
<blockquote>
<p>先进先出(FIFO)的数据结构，在队列的末端添加项，在队列的 前端移除项。</p>
</blockquote>
<ul>
<li><code>shift()</code><ul>
<li>移除数组中的第一个项，并且返回移除的项，同时将长度减1</li>
<li>结合<code>push()</code>方法，可以实现队列操作</li>
</ul>
</li>
<li><code>unshift()</code><ul>
<li>在数组的前端添加多个项并且返回修改后数组的长度；结合<code>pop()</code>方法，可以实现队列操作</li>
</ul>
</li>
</ul>
</li>
<li><p>数组中的重排序方法</p>
<ul>
<li><code>reverse()</code><ul>
<li>只是把数组颠倒个顺序，并不会对齐排序，返回经过排序的数组</li>
</ul>
</li>
<li><p><code>sort()</code></p>
<ul>
<li><p>默认是按照升序排列数组；其默认会调用每一个数组项的<code>toString()</code>转为<code>字符串进行比较</code></p>
   <figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var num1=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>]</div><div class="line">num1.sort() ; <span class="comment">//     [0, 1, 10, 15, 5]</span></div></pre></td></tr></table></figure>
<p>   这个方法不是我们需要的排序方法，所以一般在里面传递一个比较函数</p>
   <figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num=[<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>];</div><div class="line">num.sort(<span class="function"><span class="keyword">function</span><span class="params">(a,b)</span></span>&#123;</div><div class="line">         <span class="keyword">return</span> a-b;  <span class="comment">// 从小到大</span></div><div class="line">         <span class="keyword">return</span> b-a; <span class="comment">// 从大到小</span></div><div class="line">   &#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>操作数组的方法</p>
<ul>
<li><p><code>concat()</code>：连接多个数组的方法</p>
<ul>
<li>先会创建当前数组的一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新创建的数组；</li>
<li>没有传递参数，就是<code>复制当前的数组</code>，返回当前数组的副本</li>
<li>传递参数，就是把参数插入在当前的数组的副本的末尾,连接多个数组，返回修改的数组</li>
</ul>
</li>
<li><p><code>slice()</code></p>
<ul>
<li>一个参数：返回从该参数指定的位置开始到当前数组的末尾的所有项，数组的形式返回。</li>
<li>两个参数：返回起始位置到结束位置之间的项，但是不包括结束位置的项。<code>包前不包后</code></li>
<li>不影响原数组，可以传入负数，加上数组长度来计算</li>
<li>不传参数的时候，就是<code>复制原数组</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><code>splice()</code></li>
</ul>
<blockquote>
<p>主要用途就是向数组中部插入项，返回一个数组，该数组包含从原始数组删除的项，没有就返回一个空数组</p>
</blockquote>
<ul>
<li><code>删除</code>：可以删除任意数量的项<ul>
<li><code>splice(删除的第一项，要删除的项数)</code></li>
</ul>
</li>
<li><p><code>插入</code>：在指定位置插入任意项</p>
<ul>
<li><code>splice(插入起始位置，0，要插入的项（可以多个）)</code></li>
</ul>
</li>
<li><p><code>替换</code>：在指定位置插入任意项</p>
<ul>
<li><code>splice(起始位置，删除的项，要插入的项)</code></li>
</ul>
</li>
</ul>
<ul>
<li><p>位置方法</p>
<ul>
<li><code>indexOf(要查找的项，[开始查找起点位置的索引])</code>：开头找，找到返回，没有找打返回-1，严格相等</li>
<li><code>lastIndexOf(要查找的项，[开始查找起点位置的索引])</code>：结尾找，但是返回的索引值还是从前面数</li>
</ul>
</li>
<li><p>迭代方法</p>
<blockquote>
<p>接收两个参数，要在数组的每一个项上面运行的函数和（可选的）运行该函数的作用域对象—影响<code>this</code>的值，函数参数都接收三个参数：数组项的值，该项在数组中的索引值，数组对象本身</p>
</blockquote>
<ul>
<li><code>every()</code>：如果该函数参数对每一项都返回true，则返回true</li>
<li><code>filter()</code>：会返回true的项组成的数组</li>
<li><code>forEach()</code>：没有返回值，本质和for循环迭代数组一样</li>
<li><code>map()</code>：返回每次函数调用返回的结果组成的函数</li>
<li><code>some()</code>：函数参数对某一项返回true，则返回true</li>
</ul>
</li>
</ul>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> numbers=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</div><div class="line"><span class="keyword">var</span> everyR=numbers.every(<span class="function"><span class="keyword">function</span><span class="params">(item,<span class="keyword">index</span>,<span class="keyword">array</span>)</span><span class="comment">&#123;</span></span></div><div class="line">      return (item&gt;2);</div><div class="line">  &#125;)</div><div class="line"><span class="title">console</span>.<span class="title">log</span><span class="params">(everyR)</span>;  <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> someR=numbers.some(<span class="function"><span class="keyword">function</span><span class="params">(item,<span class="keyword">index</span>,<span class="keyword">array</span>)</span><span class="comment">&#123;</span></span></div><div class="line">        return (item&gt;2);</div><div class="line"> &#125;)</div><div class="line"> <span class="title">console</span>.<span class="title">log</span><span class="params">(someR)</span>;  <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> filterR=numbers.filter(<span class="function"><span class="keyword">function</span><span class="params">(item,<span class="keyword">index</span>,<span class="keyword">array</span>)</span><span class="comment">&#123;</span></span></div><div class="line">      return (item&gt;2);</div><div class="line"> &#125;)</div><div class="line"> <span class="title">console</span>.<span class="title">log</span><span class="params">(filterR)</span>; <span class="comment">// [3,4,5,4,3]</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> mapR=numbers.map(<span class="function"><span class="keyword">function</span><span class="params">(item,<span class="keyword">index</span>,<span class="keyword">array</span>)</span><span class="comment">&#123;</span></span></div><div class="line">      return (item*2);</div><div class="line"> &#125;)</div><div class="line"> <span class="title">console</span>.<span class="title">log</span><span class="params">(mapR)</span>;  <span class="comment">// [2,4,6,8,10,8,6,4,2]</span></div></pre></td></tr></table></figure>
<h3 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a><code>Date</code>类型</h3><blockquote>
<p>1970年1月1日开始经过的毫秒数</p>
</blockquote>
<ul>
<li><p>创建一个日期对象 ：<code>var now=new Date()</code></p>
<ul>
<li>没有传入参数：自动获取当前时间和日期</li>
<li>传入参数：<code>var someDate=new Date(&#39;8/1/2017&#39;)</code>，后台调用<code>Date.parse()</code>转化，获取到2017年8月1号的毫秒数</li>
</ul>
</li>
<li><p>继承的方法</p>
<ul>
<li><code>toLocaleString()</code><ul>
<li>按照浏览器的设置时区返回日期和时间</li>
</ul>
</li>
<li><code>toString()</code><ul>
<li>返回带有时区信息的日期和时间</li>
<li>与上一个方法其实没有什么差别，显示时间来说</li>
</ul>
</li>
<li><code>valueOf()</code><ul>
<li>返回日期的毫秒数，可以用来比较日期值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h4><ul>
<li><code>toDateString()</code>：以特定格式显示星期，月，日，年</li>
<li><code>toTimeString()</code>：以特定格式显示时，分，秒，时区</li>
<li><code>toLocalDateString()</code></li>
<li><code>toLocalTimeString()</code></li>
<li><code>toUTCString()</code></li>
</ul>
<h3 id="RegExg-类型"><a href="#RegExg-类型" class="headerlink" title="RegExg()类型"></a><code>RegExg()</code>类型</h3><blockquote>
<p>支持正则表达式  <code>var expression= /pattren/flags</code><br><code>pattren模式：</code><br><code>flags标志：</code>g全局，i不区分大小写，m多行模式，到达一行文本末尾还会继续查找下一行中是否存在</p>
</blockquote>
<ul>
<li>元字符<blockquote>
<p>转义，匹配的字符串里面包含元字符的话<br> <code>{ [ \ ^ $ | ] ? * + .} ( )</code></p>
</blockquote>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1811036-7311264906caafc1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="字面量转字符串"></p>
<ul>
<li><p>创建正则表达式的方法</p>
<ul>
<li>字面量<ul>
<li><code>var pattern=/\.at/gi</code>：匹配所有的<code>.at</code>不区分大小写</li>
</ul>
</li>
<li><code>RegExp()函数</code><ul>
<li><code>var pattern=new RegExp(&#39;[bc]at&#39;,&#39;i&#39;)</code>：接收字符串形式的匹配字符，和标志，里面不能直接使用字面量，</li>
</ul>
</li>
<li><code>区别：ECMAScript3中</code><ul>
<li>字面量始终会共享同一个<code>RegExp()实例</code>，而构造函数创建的每一个新的<code>RegExp实例</code>都是一个新的实例</li>
</ul>
</li>
</ul>
</li>
<li><p><code>RegExp</code>实例方法</p>
<ul>
<li><p><code>exec()</code></p>
<ul>
<li>捕获数组</li>
<li>一个参数：应用模式的字符串</li>
<li>返回值：匹配的数组<code>额外的属性：input（应用正则表达式的字符串） index（匹配项字符串中的位置）/null</code></li>
<li>当在匹配的字符串里面带有<code>g全局模式的时候</code>，每次调用<code>exec()</code>都会返回字符串中的下一个匹配项，直到结尾。<code>lastIndex</code>每次都会增加</li>
</ul>
</li>
<li><p><code>test()</code></p>
<ul>
<li>接收一串字符串</li>
<li>返回true/fasle</li>
</ul>
</li>
<li><p><code>toString()</code>和<code>toLocaleString()</code></p>
<ul>
<li>返回正则表达式的字面量</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Function类型"><a href="#Function类型" class="headerlink" title="Function类型"></a><code>Function类型</code></h3><blockquote>
<p>函数是对象，每一个函数都是<code>Function类型</code>的实例，函数名实际上是一个指向函数对象的指针，操作函数，最重要的是操作函数的属性和方法；<code>prototype</code>：保存着所有的实例方法；其是不可以枚举的，不能使用for  in循环</p>
</blockquote>
<h4 id="没有重载-重点"><a href="#没有重载-重点" class="headerlink" title="没有重载 重点"></a>没有重载 <strong>重点</strong></h4><blockquote>
<p>重载：让类以统一的方式处理不同类型数据的一种手段。重载<code>Overloading</code>是一个类中多态性的一种表现。方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不相同。</p>
</blockquote>
<ul>
<li><p>函数声明和函数表达式 </p>
<blockquote>
<p>解析器在向执行环境中加载数据的时候，会先读取函数声明（函数变量提升），并使其在执行任何代码之前都可以访问，等到解析器真正要执行函数所在的代码行的时候，才会执行函数表达式</p>
</blockquote>
<figure class="highlight scilab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alert(<span class="built_in">sum</span>(<span class="number">10</span>,<span class="number">10</span>))</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sun</span><span class="params">(num1,num2)</span>&#123;</span></div><div class="line">       <span class="keyword">return</span> num1+num2  <span class="comment">// 把函数的声明放在执行环境顶部，但是我们使用函数表达式的时候，就会出现错误，不会函数变量提升</span></div><div class="line"> &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>函数内部属性</p>
<ul>
<li><code>arguments</code><ul>
<li>类数组对象，包含传入函数中的所有参数，主要是用来保存函数参数的</li>
<li>还有一个<code>callee属性</code>，是一个指针，指向拥有<code>arguments</code>对象的函数</li>
</ul>
</li>
</ul>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">    // 阶乘函数</span></div><div class="line">    function factoriai(num)&#123;</div><div class="line">      if(num&lt;=1)&#123;</div><div class="line">     return 1;</div><div class="line">      &#125;else&#123;</div><div class="line">         return num*arguments.callee(num-1);  // num*facoriai(num-1)</div><div class="line">       &#125;</div><div class="line">     &#125;   </div><div class="line">  ```   </div><div class="line">  </div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line">好处是在于：不需要知道函数的名字就可以完成递归调用，降低函数体内的代码与函数名的耦合度</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  -<span class="ruby"> <span class="string">`this`</span></span></div><div class="line">     -<span class="ruby"> 函数执行的环境对象</span></div><div class="line">     -<span class="ruby"> 全局函数，指向<span class="string">`window`</span>；谁调用函数就指向谁</span></div><div class="line">     </div><div class="line">  -<span class="ruby"> 函数中的非继承的方法：<span class="string">`apply(),call()`</span></span></div><div class="line">     -<span class="ruby"> 设置函数体内的<span class="string">`this`</span>对象的值</span></div><div class="line">     -<span class="ruby"> <span class="string">`apply()`</span></span></div><div class="line">         -<span class="ruby"> 参数：运行函数的作用域（必须传入），参数数组（arguments对象或者Array实例）</span></div><div class="line">     -<span class="ruby"> <span class="string">`call()`</span></span></div><div class="line">         -<span class="ruby">  参数：运行函数的作用域（必须传入），参数必须逐个列举出来</span></div><div class="line"> </div><div class="line">  -<span class="ruby"> 这两种方法没有什么不同，就是取决你给函数传递的参数的方式，真正的作用是扩充函数运行的作用域，对象不需要与方法有任何的耦合关系。</span></div></pre></td></tr></table></figure>
<pre><code>window.color=&apos;red&apos;;
var o={color:&apos;blue&apos;}
function sayColor(){
   alert(this.color)
}
sayColor();  // red
sayColor.call(this);  // red
sayColor.call(o);  // blue    
</code></pre> <figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="clean">- `bind()`</span></div><div class="line">   - 创建一个函数的实例，其`this`值会绑定到传给`bind()`函数的值。</div><div class="line">   - 即使在全局作用域调用这个函数，函数里面的`this`也是指向绑定的函数的`this`</div></pre></td></tr></table></figure>
<p>   window.color=’red’;<br>   var o={color:’blue’}<br>   function sayColor(){</p>
<pre><code>alert(this.color)
</code></pre><p>   }</p>
<pre><code>var objectS=sayColor.bind(o);
</code></pre><p>   objectS();  // blue  全局调用也是执行o对象中的this<br>```</p>
</li>
</ul>
<h3 id="基本包装类"><a href="#基本包装类" class="headerlink" title="基本包装类"></a>基本包装类</h3><ul>
<li><code>Boolean</code></li>
<li><code>Number</code></li>
<li><code>String</code></li>
<li>映射到同名的基本类型</li>
</ul>
<h3 id="单体内置对象"><a href="#单体内置对象" class="headerlink" title="单体内置对象"></a>单体内置对象</h3><ul>
<li><p><code>URL编码方法</code></p>
<ul>
<li><code>encodeURI()</code>：整个url，空格换成了<code>%20</code>  对应的<code>decodeURI()</code></li>
<li><code>encodeURIComponent()</code>：url中的某一段</li>
</ul>
</li>
<li><p><code>eval()</code></p>
<ul>
<li>一个完整的解析器</li>
<li>参数：一个；要<code>执行</code>的字符串</li>
</ul>
</li>
</ul>
<div id="music163player"><br><br>  <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=22453837&auto=1&height=66"></iframe><br></div>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;  引用类型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对象是某个特定的引用类型的实例。新对象是使用&lt;code&gt;new&lt;/code&gt;操作符后跟一个构造函数来创建的。&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; preson=&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://icessun.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javascript" scheme="http://icessun.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>告别秋千</title>
    <link href="http://icessun.github.io/%E5%91%8A%E5%88%AB%E7%A7%8B%E5%8D%83.html"/>
    <id>http://icessun.github.io/告别秋千.html</id>
    <published>2017-08-01T03:58:00.000Z</published>
    <updated>2017-08-03T08:08:41.313Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/1811036-5c11bf8da7b55777.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="秋千"></p>
<blockquote class="blockquote-center"><br><br>我们习惯了沉湎于回忆，却忘了自己也在一点一点变旧。沾染尘埃，锈迹了生活。<br><br>听很多的歌，像吸食大量的鸦片。<br><br>震耳欲聋，乐此不疲。<br><br>耳膜在享受着肆虐的快感。心 ，却是寂寂的，不发一语。<br><br>暮色四拢的时候，总有飞机飞过。信号灯明灭着呼啸而去。<br><br>有人沉默的远去了，有人正急切的赶赴一场相聚。<br><br>高空上演绎着起伏的悲欢。<br><br>而我，能做的不过是紧了紧书包。<br><br>转身，面无表情。<br><br>心中沟壑千条，那些人那些事早已不复原貌。<br><br>只是这旧日的影子仍旧在徘徊着，鲜活的不似曾经。<br><br>东风摇百草，四顾何茫茫。<br><br>我是如此怀念亲爱的你们，以及一不小心就不见了的自己。<br><br>那时候烂漫无知的笑啊，胸无城府的小算计呀，傻里傻气的故弄清高。<br><br>沉醉了自己，撞进了谁人的眼里。<br><br>那些扬花三月般的时光，连同无知岁月里的欢笑、泪水。<br><br>就这样，一路跑着，留一串未明的歌谣，面容模糊的远去了。<br><br>当所有的悲伤逆袭而来，我连自嘲的勇气都没有。<br><br>于是，快乐的时候不再快乐，悲伤的时候仍旧悲伤。<br><br>青春，终究是一个人的过场。<br><br>一路丢盔弃甲，一路溃不成军。<br><br>成长，本就如人饮水，冷暖自知。<br><br>亦如人情，本就凉薄。<br><br>全身而退，到底是一种奢求。<br><br>——致面容模糊的过去<br><br><br><br><br><br></blockquote>

<div id="music163player"><br>  <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=22453837&auto=1&height=66"></iframe><br></div>
]]></content>
    
    <summary type="html">
    
      告别秋千
    
    </summary>
    
    
      <category term="杂七杂八" scheme="http://icessun.github.io/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
  </entry>
  
</feed>
