<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>icessun&#39;s Blog</title>
  <subtitle>有酒有故事</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://icessun.github.io/"/>
  <updated>2017-08-03T09:15:51.792Z</updated>
  <id>http://icessun.github.io/</id>
  
  <author>
    <name>icessun</name>
    <email>icessun@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>javascript高级程序设计读书笔记（四）</title>
    <link href="http://icessun.github.io/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89.html"/>
    <id>http://icessun.github.io/javascript高级程序设计读书笔记（四）.html</id>
    <published>2017-08-03T02:20:38.000Z</published>
    <updated>2017-08-03T09:15:51.792Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>变量，作用域，和内存的问题</p></blockquote><a id="more"></a><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><blockquote><p>不存在定义一个变量就保存这种数据类型的值的规则，一个变量的值和数据类型可以在脚本的生命周期内改变。</p><ul><li>基本类型的值</li><li>引用类型的值</li></ul></blockquote><h4 id="基本类型的值"><a href="#基本类型的值" class="headerlink" title="基本类型的值"></a>基本类型的值</h4><blockquote><p>基本数据类型是<strong>按照值访问的</strong>，可以操作保存在变量里面实际的值</p></blockquote><ul><li>字符串</li><li>数值<ul><li><code>NaN</code>：特殊的数值型；<code>isNaN()</code>：返回是否是不是数值</li><li><code>isNaN()</code>被对象调用的时候，会首先调用对象的<code>valueOf()</code>，看其是否可以转为数值；不能，则基于这个返回值在调用<code>toString()</code>，再看是否是数值</li></ul></li><li>布尔值</li><li><code>undefined</code></li><li><code>null</code><ul><li>只要意在保存的变量还没有真正保存对象，就应该明确的让该变量保存<code>null</code>，体现出<code>null</code>是空对象指针。</li></ul></li></ul><blockquote><p>字符串，数值和布尔值都有<code>toString()</code>方法，但<code>undefined</code>和<code>null</code>没有此方法，但是可以使用<code>String()</code>，这个方法可以传入<code>基数</code>，输出二进制或者八进制或者十六进制的字符串值</p></blockquote><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">转为true的值</th><th style="text-align:center">转为false的值</th></tr></thead><tbody><tr><td style="text-align:center">Boolean</td><td style="text-align:center">true</td><td style="text-align:center">false</td></tr><tr><td style="text-align:center">Number</td><td style="text-align:center">任何非0数字，包括无穷大</td><td style="text-align:center">0和NaN</td></tr><tr><td style="text-align:center">String</td><td style="text-align:center">任何非空字符串</td><td style="text-align:center">‘ ‘(空字符串)</td></tr><tr><td style="text-align:center">Object</td><td style="text-align:center">任何对象</td><td style="text-align:center">null</td></tr><tr><td style="text-align:center">Undefined</td><td style="text-align:center">不适用</td><td style="text-align:center">undefined</td></tr></tbody></table><p>在内存中占据固定大小的空间，因此保存在<code>栈内存</code>里面</p><h4 id="引用类型的值"><a href="#引用类型的值" class="headerlink" title="引用类型的值"></a>引用类型的值</h4><blockquote><p>是保存在内存中的对象，是<strong>按照引用来访问</strong>的，因为，<code>JS</code>是不允许直接访问内存中的位置，也就不能直接操作对象的内存空间，实际上是操作对象的引用</p></blockquote><p>引用类型的值是对象，保存在<code>堆内存</code>中</p><ul><li><code>Object类型</code><blockquote><p>对象其实就是数据和功能的集合，<code>Object类型</code>是所有它的实例的基础，其所具有的任何的属性和方法同样都存在更具体的对象中。</p></blockquote></li></ul><h4 id="两种值的不同点"><a href="#两种值的不同点" class="headerlink" title="两种值的不同点"></a>两种值的不同点</h4><ul><li>当定义一个引用类型的变量，可以为其动态的添加属性和方法，但是基本类型的变量就不可以，虽然操作是不会出现错误，返回<code>undefined</code></li><li><p>基本类型的变量的复制</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var <span class="attribute">num1</span>=5;</div><div class="line">var <span class="attribute">num1</span>=num2;</div></pre></td></tr></table></figure></li></ul><ul><li>num1和num2是<strong>相互独立</strong>的，互不影响，在内存空间里面分配不同的空间</li></ul><ul><li><p>引用类型值的复制：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1=<span class="keyword">new</span> <span class="type">Person</span>();</div><div class="line"><span class="keyword">var</span> obj2=obj1;</div></pre></td></tr></table></figure></li><li><p>此时的obj2和obj1是指向同一个地址空间，之间的复制是把引用，也就是指向这个对象的内存空间的<strong>指针复制</strong>了一份，当操作obj1的属性的时候，obj2也受到影响</p></li></ul><h4 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h4><blockquote><p><code>ECMAScript</code>中所有函数的参数都是<code>按值传递</code>的。就是把值，从外部的变量，复制一份给函数中参数变量。传递基本类型的值给函数中的参数的时候，被传递的值被复制给函数参数<code>aguments</code>对象的一个元素，局部变量；给参数传递引用类型的时候，就是把这个值在内存中的地址复制给<code>arguments</code>中的一个局部变量，所以这个局部变量变化会反映在函数的外部。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">       obj.name=<span class="string">'icessun'</span>;</div><div class="line">       obj=<span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">       obj.name=<span class="string">'icessun1'</span>;  <span class="comment">//将新的对象赋值给obj对象并设置name属性 </span></div><div class="line">  &#125; </div><div class="line">  <span class="keyword">var</span> person=<span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">  setName(person);</div><div class="line">  alert(person.name);   <span class="comment">// 弹出icessun  这说明参数的传递是按照值来的</span></div></pre></td></tr></table></figure><p>上面的代码说明，参数是按照值传递的，因为在函数<code>setName</code>中，重新赋值一个对象给<code>obj</code>，并且改变了其<code>name</code>属性，要是按照引用传递的话，那么后面弹出来的是<code>icessun1</code>；结果却不是这样，这说明：</p><blockquote><p>函数内部改变了参数的值，但是原始的引用保持不变；因为在函数内部重写参数时，这个变量引用就是一个局部变量，会在函数执行完毕立即销毁。</p></blockquote><h4 id="类型检测"><a href="#类型检测" class="headerlink" title="类型检测"></a>类型检测</h4><ul><li><code>typeof</code><ul><li>字符串 ——&gt; <code>string</code><br><code>var n; console.log(typeof n); // undefined</code></li><li>数值 ——-&gt; <code>number</code></li><li>布尔值 ——–&gt; <code>boolean</code></li><li><code>undefined</code> ——-&gt; <code>undefined</code></li></ul></li></ul><p><code>unll == undefined; true</code></p><blockquote><p><code>typeof</code>是检测上面这几种类型的最佳工具，但是对于<code>null</code>和<code>对象</code>都返回<code>object</code>，因为<code>null</code>表示一个空对象指针，所以<code>typeof null</code>为<code>Object</code>；检测函数的时候，会返回<code>function</code>；这是区分函数和其他对象的方法，函数是一个对象，不是一种数据类型。</p></blockquote><p>对于未声明的变量和为初始化的变量，执行<code>typeof</code>操作都返回<code>undefined</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message; <span class="comment">//  未初始化</span></div><div class="line"><span class="comment">// var age;   未声明</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> message);  <span class="comment">// undefined</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> age);     <span class="comment">// undefined</span></div></pre></td></tr></table></figure><ul><li><code>instanceof</code> ：检测什么类型的对象（引用类型）</li></ul><blockquote><p><code>variable instanceof constructor</code> 返回<code>true/false</code></p></blockquote><ul><li><code>Object</code></li><li><code>Array</code></li><li><code>RegExp</code><br>如果变量是给定引用类型的实例，那么<code>instanceof</code>之后返回的结果都是<code>true</code>；基本类型不是对象，都返回<code>false</code>。所有的引用类型的值都是<code>Object</code>的实例。</li></ul><h4 id="执行环境和作用域"><a href="#执行环境和作用域" class="headerlink" title="执行环境和作用域"></a>执行环境和作用域</h4><blockquote><p>执行环境定义了变量和函数有权访问的其他数据。决定了各自的行为。某个执行环境中的所有代码执行完毕，该环境就被销毁，保存在里面的所有的变量和函数定义也随之销毁。每个函数都有自己的执行环境，当执行这个函数的时候，会把这个函数推入到一个环境栈里面，直到函数执行完成，再从环境栈里面弹出，交到之前的执行环境。</p></blockquote><ul><li>作用域链<ul><li>保证对执行环境有权访问的所有变量和函数的有序访问；其前端，始终是当前执行代码的所在环境的变量对象<code>环境是函数，则这个活动对象就是arguments对象</code>。下一个变量对象来自包含环境（包含当前变量对象的外部环境），就这样一直延续到全局执行环境，故全局的执行环境是作用域链的最后一个对象。</li></ul></li></ul><figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="built_in">color</span>=<span class="string">'blue'</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">color</span>===<span class="string">'blue'</span>)&#123;</div><div class="line">         <span class="built_in">color</span>=<span class="string">'red'</span>;</div><div class="line">     &#125;<span class="title">else</span>&#123;</div><div class="line">         <span class="built_in">color</span>=<span class="string">'blue'</span>;</div><div class="line">      &#125;</div><div class="line"> &#125;</div><div class="line"> changeColor();</div><div class="line"> <span class="built_in">console</span>.log(<span class="string">'Color is now'</span>+<span class="built_in">color</span>);</div></pre></td></tr></table></figure><p>上面的代码中，函数的作用域链包含两个对象：自己的变量对象<code>arguments对象</code>和全局环境的变量对象。可以在函数内部访问到全局的变量，因为在其的作用域链上面可以找到。<br></p><figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">作用域链： </div><div class="line">    -<span class="ruby"> window</span></div><div class="line">       -<span class="ruby"> color</span></div><div class="line">       -<span class="ruby"> changeColor()</span></div><div class="line">          -<span class="ruby"> arguments</span></div></pre></td></tr></table></figure><p></p><p>每一个环境都可以向上搜索作用域链，查询变量和函数名，但是不能向下搜索作用域链；函数参数也是函数执行环境中内部的变量，局部变量。</p><ul><li><p>延长作用域链</p><ul><li><code>try-catch语句</code>中的<code>catch块</code></li><li><code>with语句</code></li></ul></li><li><p><code>没有块级作用域</code></p><blockquote><p>在其他的类<code>C</code>语言，由花括号封闭的代码块都有自己的作用域，因而支持根据条件来定义变量。但是<code>JavaScript</code>没有块级作用域</p></blockquote><ul><li><p>声明变量</p><blockquote><p>使用<code>var</code>声明的变量会自动添加到<code>最接近的环境中</code>：在函数内部，最接近的就是函数的局部环境；在<code>with</code>语句中，最接近的是函数环境；如果初始化变量时没有使用<code>var</code>，则会自动把该变量添加到全局环境中。</p></blockquote><ul><li><strong>注意</strong>：<br>在<code>javascript</code>中，由<code>for</code>语句创建的变量<code>i</code>（由<code>var</code>声明的），即使循环结束，也依旧存在循环外部的执行环境中。</li></ul></li><li><p>作用域向上搜索</p><p>在执行环境中查找一个变量的时候，在局部环境里面找到，就直接使用；否者，继续向上的作用域链查找，没有找到，说明该变量没有声明。</p></li></ul></li></ul><h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><blockquote><p><code>javascript</code>中有自动垃圾回收机制；原理就是：找到那些不再需要继续使用的变量，然后释放其占用的内存。垃圾回收机制会按照固定的时间间隔，周期性的去执行这一操作。</p></blockquote><ul><li>标记清除<br>给存储在内存中的变量都加上标记，然后去掉环境中的变量标记以及被环境中的变量引用的变量的标记；之后再加上的标记的变量是当做准备删除的变量，因为环境中的变量已经无法访问到这些变量了；最后，垃圾回收器完成垃圾的回收。</li><li>计数清除<br>记录每一个值被引用的次数，当声明了一个变量并将一个引用类型赋值给该变量的时候，引用次数为1，如果同一个值又被赋给其他的变量，该值引用次数就加1，包含对这个值引用的变量又取得另外一个值，则这个值的引用次数减1，当次数为0的时候就说明不能访问到，应该回收；<strong>坏结果</strong>：循环引用。</li></ul><p><code>IE9</code>把<code>BOM</code>和<code>DOM</code>对象都转换成真正的<code>JavaScript</code>对象。就避免了垃圾回收的问题，也消除了常见的内存泄漏现象。</p><p>一般来说：一旦数据不再使用，最好手动将其设置为<code>null</code>，来释放其引用，适合大多数的全局变量和全局对象的属性。局部变量会在离开执行环境的时候自动解除引用。解除引用，是让值脱离执行环境，等待垃圾回收运行将其回收。</p><div id="music163player"><br><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=22453837&auto=1&height=66"></iframe><br><br></div>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;变量，作用域，和内存的问题&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://icessun.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javascript" scheme="http://icessun.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript高级程序设计读书笔记（五）</title>
    <link href="http://icessun.github.io/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89.html"/>
    <id>http://icessun.github.io/javascript高级程序设计读书笔记（五）.html</id>
    <published>2017-08-03T02:20:13.000Z</published>
    <updated>2017-08-04T03:21:29.879Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>引用类型</p></blockquote><p>对象是某个特定的引用类型的实例。新对象是使用<code>new</code>操作符后跟一个构造函数来创建的。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> preson=<span class="keyword">new</span> <span class="built_in">Object</span>();</div></pre></td></tr></table></figure><a id="more"></a><h3 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a><code>Object</code>类型</h3><ul><li><p>创建对象的方法</p><ul><li><code>new</code>+构造函数 ：<code>var preson=new Object()</code></li><li><p>对象字面量 ：向函数传递大量<code>可选参数</code>的首选方式</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var <span class="keyword">person</span>=&#123;</div><div class="line">           name:'icessun',    &lt;=====&gt;var <span class="keyword">person</span>=&#123; &#125;;</div><div class="line">           age:18</div><div class="line">   &#125;</div><div class="line"></div><div class="line">访问对象的属性：<span class="keyword">person</span>.属性；<span class="keyword">person</span><span class="comment">[属性]</span>，【】一般是通过变量来访问属性</div></pre></td></tr></table></figure></li></ul></li></ul><h3 id="Array类型"><a href="#Array类型" class="headerlink" title="Array类型"></a><code>Array</code>类型</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors=<span class="keyword">new</span> <span class="type">Array</span>();  里面可以写入一个数值，表示数组的长度<span class="keyword">new</span> <span class="type">Array</span>(<span class="number">20</span>)；也可以直接在里面写入数组的值<span class="keyword">new</span> <span class="type">Array</span>(<span class="string">'red'</span>,<span class="string">'blue'</span>,<span class="string">'green'</span>)</div><div class="line"></div><div class="line">字面量方式：</div><div class="line"><span class="keyword">var</span> colors=[<span class="string">'red'</span>,<span class="string">'blue'</span>,<span class="string">'green'</span>]  <span class="comment">//不会调用Array的构造函数</span></div></pre></td></tr></table></figure><ul><li><p>检测数组</p><ul><li><code>instanceof</code><ul><li>是在单一的全局执行环境中检测数组，对于从一个执行环境中传递到另一个执行环境中的数组是检测不出来的</li></ul></li><li><code>Array.isArray()</code><ul><li>这个方法确定某个值到底是不是数组，而不管是在哪个全局执行环境创建的</li></ul></li></ul></li><li><p>转换方法</p><blockquote><p>所有的对象都具有<code>toLocaleString(),toString(),valueOf()</code></p></blockquote><ul><li><code>toString()</code>：默认是用<code>逗号</code>隔开返回数组的每个值的字符串</li><li><code>join([分隔符])</code>：使用不同的分隔符来返回数组每个值的字符串</li></ul></li><li><p>数组中的栈方法</p><blockquote><p>后进先出(LIFO)的数据结构，栈中项的插入和删除只发生在—-栈的顶部。</p></blockquote><ul><li><code>push()</code><ul><li>传入要在数组末尾添加的数据，返回修改后数组的长度</li></ul></li><li><code>pop()</code><ul><li>删除数组末尾的最后一项（取得数组中的最后一项），返回被删除的项</li></ul></li></ul></li><li><p>数组中的队列方法</p><blockquote><p>先进先出(FIFO)的数据结构，在队列的末端添加项，在队列的 前端移除项。</p></blockquote><ul><li><code>shift()</code><ul><li>移除数组中的第一个项，并且返回移除的项，同时将长度减1</li><li>结合<code>push()</code>方法，可以实现队列操作</li></ul></li><li><code>unshift()</code><ul><li>在数组的前端添加多个项并且返回修改后数组的长度；结合<code>pop()</code>方法，可以实现队列操作</li></ul></li></ul></li><li><p>数组中的重排序方法</p><ul><li><code>reverse()</code><ul><li>只是把数组颠倒个顺序，并不会对齐排序，返回经过排序的数组</li></ul></li><li><p><code>sort()</code></p><ul><li><p>默认是按照升序排列数组；其默认会调用每一个数组项的<code>toString()</code>转为<code>字符串进行比较</code></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var num1=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>]</div><div class="line">num1.sort() ; <span class="comment">//     [0, 1, 10, 15, 5]</span></div></pre></td></tr></table></figure><p>这个方法不是我们需要的排序方法，所以一般在里面传递一个比较函数</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num=[<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>];</div><div class="line">num.sort(<span class="function"><span class="keyword">function</span><span class="params">(a,b)</span></span>&#123;</div><div class="line">         <span class="keyword">return</span> a-b;  <span class="comment">// 从小到大</span></div><div class="line">         <span class="keyword">return</span> b-a; <span class="comment">// 从大到小</span></div><div class="line">   &#125;)</div></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>操作数组的方法</p><ul><li><p><code>concat()</code>：连接多个数组的方法</p><ul><li>先会创建当前数组的一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新创建的数组；</li><li>没有传递参数，就是<code>复制当前的数组</code>，返回当前数组的副本</li><li>传递参数，就是把参数插入在当前的数组的副本的末尾,连接多个数组，返回修改的数组</li></ul></li><li><p><code>slice()</code></p><ul><li>一个参数：返回从该参数指定的位置开始到当前数组的末尾的所有项，数组的形式返回。</li><li>两个参数：返回起始位置到结束位置之间的项，但是不包括结束位置的项。<code>包前不包后</code></li><li>不影响原数组，可以传入负数，加上数组长度来计算</li><li>不传参数的时候，就是<code>复制原数组</code></li></ul></li></ul></li></ul><ul><li><code>splice()</code></li></ul><blockquote><p>主要用途就是向数组中部插入项，返回一个数组，该数组包含从原始数组删除的项，没有就返回一个空数组</p></blockquote><ul><li><code>删除</code>：可以删除任意数量的项<ul><li><code>splice(删除的第一项，要删除的项数)</code></li></ul></li><li><p><code>插入</code>：在指定位置插入任意项</p><ul><li><code>splice(插入起始位置，0，要插入的项（可以多个）)</code></li></ul></li><li><p><code>替换</code>：在指定位置插入任意项</p><ul><li><code>splice(起始位置，删除的项，要插入的项)</code></li></ul></li></ul><ul><li><p>位置方法</p><ul><li><code>indexOf(要查找的项，[开始查找起点位置的索引])</code>：开头找，找到返回，没有找打返回-1，严格相等</li><li><code>lastIndexOf(要查找的项，[开始查找起点位置的索引])</code>：结尾找，但是返回的索引值还是从前面数</li></ul></li><li><p>迭代方法</p><blockquote><p>接收两个参数，要在数组的每一个项上面运行的函数和（可选的）运行该函数的作用域对象—影响<code>this</code>的值，函数参数都接收三个参数：数组项的值，该项在数组中的索引值，数组对象本身</p></blockquote><ul><li><code>every()</code>：如果该函数参数对每一项都返回true，则返回true</li><li><code>filter()</code>：会返回true的项组成的数组</li><li><code>forEach()</code>：没有返回值，本质和for循环迭代数组一样</li><li><code>map()</code>：返回每次函数调用返回的结果组成的函数</li><li><code>some()</code>：函数参数对某一项返回true，则返回true</li></ul></li></ul><figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> numbers=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</div><div class="line"><span class="keyword">var</span> everyR=numbers.every(<span class="function"><span class="keyword">function</span><span class="params">(item,<span class="keyword">index</span>,<span class="keyword">array</span>)</span><span class="comment">&#123;</span></span></div><div class="line">      return (item&gt;2);</div><div class="line">  &#125;)</div><div class="line"><span class="title">console</span>.<span class="title">log</span><span class="params">(everyR)</span>;  <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> someR=numbers.some(<span class="function"><span class="keyword">function</span><span class="params">(item,<span class="keyword">index</span>,<span class="keyword">array</span>)</span><span class="comment">&#123;</span></span></div><div class="line">        return (item&gt;2);</div><div class="line"> &#125;)</div><div class="line"> <span class="title">console</span>.<span class="title">log</span><span class="params">(someR)</span>;  <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> filterR=numbers.filter(<span class="function"><span class="keyword">function</span><span class="params">(item,<span class="keyword">index</span>,<span class="keyword">array</span>)</span><span class="comment">&#123;</span></span></div><div class="line">      return (item&gt;2);</div><div class="line"> &#125;)</div><div class="line"> <span class="title">console</span>.<span class="title">log</span><span class="params">(filterR)</span>; <span class="comment">// [3,4,5,4,3]</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> mapR=numbers.map(<span class="function"><span class="keyword">function</span><span class="params">(item,<span class="keyword">index</span>,<span class="keyword">array</span>)</span><span class="comment">&#123;</span></span></div><div class="line">      return (item*2);</div><div class="line"> &#125;)</div><div class="line"> <span class="title">console</span>.<span class="title">log</span><span class="params">(mapR)</span>;  <span class="comment">// [2,4,6,8,10,8,6,4,2]</span></div></pre></td></tr></table></figure><h3 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a><code>Date</code>类型</h3><blockquote><p>1970年1月1日开始经过的毫秒数</p></blockquote><ul><li><p>创建一个日期对象 ：<code>var now=new Date()</code></p><ul><li>没有传入参数：自动获取当前时间和日期</li><li>传入参数：<code>var someDate=new Date(&#39;8/1/2017&#39;)</code>，后台调用<code>Date.parse()</code>转化，获取到2017年8月1号的毫秒数</li></ul></li><li><p>继承的方法</p><ul><li><code>toLocaleString()</code><ul><li>按照浏览器的设置时区返回日期和时间</li></ul></li><li><code>toString()</code><ul><li>返回带有时区信息的日期和时间</li><li>与上一个方法其实没有什么差别，显示时间来说</li></ul></li><li><code>valueOf()</code><ul><li>返回日期的毫秒数，可以用来比较日期值</li></ul></li></ul></li></ul><h4 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h4><ul><li><code>toDateString()</code>：以特定格式显示星期，月，日，年</li><li><code>toTimeString()</code>：以特定格式显示时，分，秒，时区</li><li><code>toLocalDateString()</code></li><li><code>toLocalTimeString()</code></li><li><code>toUTCString()</code></li></ul><h3 id="RegExg-类型"><a href="#RegExg-类型" class="headerlink" title="RegExg()类型"></a><code>RegExg()</code>类型</h3><blockquote><p>支持正则表达式 <code>var expression= /pattren/flags</code><br><code>pattren模式：</code><br><code>flags标志：</code>g全局，i不区分大小写，m多行模式，到达一行文本末尾还会继续查找下一行中是否存在</p></blockquote><ul><li>元字符<blockquote><p>转义，匹配的字符串里面包含元字符的话<br><code>{ [ \ ^ $ | ] ? * + .} ( )</code></p></blockquote></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1811036-7311264906caafc1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="字面量转字符串"></p><ul><li><p>创建正则表达式的方法</p><ul><li>字面量<ul><li><code>var pattern=/\.at/gi</code>：匹配所有的<code>.at</code>不区分大小写</li></ul></li><li><code>RegExp()函数</code><ul><li><code>var pattern=new RegExp(&#39;[bc]at&#39;,&#39;i&#39;)</code>：接收字符串形式的匹配字符，和标志，里面不能直接使用字面量，</li></ul></li><li><code>区别：ECMAScript3中</code><ul><li>字面量始终会共享同一个<code>RegExp()实例</code>，而构造函数创建的每一个新的<code>RegExp实例</code>都是一个新的实例</li></ul></li></ul></li><li><p><code>RegExp</code>实例方法</p><ul><li><p><code>exec()</code></p><ul><li>捕获数组</li><li>一个参数：应用模式的字符串</li><li>返回值：匹配的数组<code>额外的属性：input（应用正则表达式的字符串） index（匹配项字符串中的位置）/null</code></li><li>当在匹配的字符串里面带有<code>g全局模式的时候</code>，每次调用<code>exec()</code>都会返回字符串中的下一个匹配项，直到结尾。<code>lastIndex</code>每次都会增加</li></ul></li><li><p><code>test()</code></p><ul><li>接收一串字符串</li><li>返回true/fasle</li></ul></li><li><p><code>toString()</code>和<code>toLocaleString()</code></p><ul><li>返回正则表达式的字面量</li></ul></li></ul></li></ul><h3 id="Function类型"><a href="#Function类型" class="headerlink" title="Function类型"></a><code>Function类型</code></h3><blockquote><p>函数是对象，每一个函数都是<code>Function类型</code>的实例，函数名实际上是一个指向函数对象的指针，操作函数，最重要的是操作函数的属性和方法；<code>prototype</code>：保存着所有的实例方法；其是不可以枚举的，不能使用for in循环</p></blockquote><h4 id="没有重载-重点"><a href="#没有重载-重点" class="headerlink" title="没有重载 重点"></a>没有重载 <strong>重点</strong></h4><blockquote><p>重载：让类以统一的方式处理不同类型数据的一种手段。重载<code>Overloading</code>是一个类中多态性的一种表现。方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不相同。</p></blockquote><ul><li><p>函数声明和函数表达式</p><blockquote><p>解析器在向执行环境中加载数据的时候，会先读取函数声明（函数变量提升），并使其在执行任何代码之前都可以访问，等到解析器真正要执行函数所在的代码行的时候，才会执行函数表达式</p></blockquote><figure class="highlight scilab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alert(<span class="built_in">sum</span>(<span class="number">10</span>,<span class="number">10</span>))</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sun</span><span class="params">(num1,num2)</span>&#123;</span></div><div class="line">       <span class="keyword">return</span> num1+num2  <span class="comment">// 把函数的声明放在执行环境顶部，但是我们使用函数表达式的时候，就会出现错误，不会函数变量提升</span></div><div class="line"> &#125;</div></pre></td></tr></table></figure></li></ul><ul><li><p>函数内部属性</p><ul><li><code>arguments</code><ul><li>类数组对象，包含传入函数中的所有参数，主要是用来保存函数参数的</li><li>还有一个<code>callee属性</code>，是一个指针，指向拥有<code>arguments</code>对象的函数</li></ul></li></ul><figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">    // 阶乘函数</span></div><div class="line">    function factoriai(num)&#123;</div><div class="line">      if(num&lt;=1)&#123;</div><div class="line">     return 1;</div><div class="line">      &#125;else&#123;</div><div class="line">         return num*arguments.callee(num-1);  // num*facoriai(num-1)</div><div class="line">       &#125;</div><div class="line">     &#125;   </div><div class="line">  ```   </div><div class="line">  </div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line">好处是在于：不需要知道函数的名字就可以完成递归调用，降低函数体内的代码与函数名的耦合度</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  -<span class="ruby"> <span class="string">`this`</span></span></div><div class="line">     -<span class="ruby"> 函数执行的环境对象</span></div><div class="line">     -<span class="ruby"> 全局函数，指向<span class="string">`window`</span>；谁调用函数就指向谁</span></div><div class="line">     </div><div class="line">  -<span class="ruby"> 函数中的非继承的方法：<span class="string">`apply(),call()`</span></span></div><div class="line">     -<span class="ruby"> 设置函数体内的<span class="string">`this`</span>对象的值</span></div><div class="line">     -<span class="ruby"> <span class="string">`apply()`</span></span></div><div class="line">         -<span class="ruby"> 参数：运行函数的作用域（必须传入），参数数组（arguments对象或者Array实例）</span></div><div class="line">     -<span class="ruby"> <span class="string">`call()`</span></span></div><div class="line">         -<span class="ruby">  参数：运行函数的作用域（必须传入），参数必须逐个列举出来</span></div><div class="line"> </div><div class="line">  -<span class="ruby"> 这两种方法没有什么不同，就是取决你给函数传递的参数的方式，真正的作用是扩充函数运行的作用域，对象不需要与方法有任何的耦合关系。</span></div></pre></td></tr></table></figure><pre><code>window.color=&apos;red&apos;;
var o={color:&apos;blue&apos;}
function sayColor(){
   alert(this.color)
}
sayColor();  // red
sayColor.call(this);  // red
sayColor.call(o);  // blue    
</code></pre><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="clean">- `bind()`</span></div><div class="line">   - 创建一个函数的实例，其`this`值会绑定到传给`bind()`函数的值。</div><div class="line">   - 即使在全局作用域调用这个函数，函数里面的`this`也是指向绑定的函数的`this`</div></pre></td></tr></table></figure><p>window.color=’red’;<br>var o={color:’blue’}<br>function sayColor(){</p><pre><code>alert(this.color)
</code></pre><p>}</p><pre><code>var objectS=sayColor.bind(o);
</code></pre><p>objectS(); // blue 全局调用也是执行o对象中的this<br>```</p></li></ul><h3 id="基本包装类"><a href="#基本包装类" class="headerlink" title="基本包装类"></a>基本包装类</h3><ul><li><code>Boolean</code></li><li><code>Number</code></li><li><code>String</code></li><li>映射到同名的基本类型</li></ul><h3 id="单体内置对象"><a href="#单体内置对象" class="headerlink" title="单体内置对象"></a>单体内置对象</h3><ul><li><p><code>URL编码方法</code></p><ul><li><code>encodeURI()</code>：整个url，空格换成了<code>%20</code> 对应的<code>decodeURI()</code></li><li><code>encodeURIComponent()</code>：url中的某一段</li></ul></li><li><p><code>eval()</code></p><ul><li>一个完整的解析器</li><li>参数：一个；要<code>执行</code>的字符串</li></ul></li></ul><div id="music163player"><br><br><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=22453837&auto=1&height=66"></iframe><br></div>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;引用类型&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;对象是某个特定的引用类型的实例。新对象是使用&lt;code&gt;new&lt;/code&gt;操作符后跟一个构造函数来创建的。&lt;/p&gt;&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; preson=&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://icessun.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javascript" scheme="http://icessun.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>告别秋千</title>
    <link href="http://icessun.github.io/%E5%91%8A%E5%88%AB%E7%A7%8B%E5%8D%83.html"/>
    <id>http://icessun.github.io/告别秋千.html</id>
    <published>2017-08-01T03:58:00.000Z</published>
    <updated>2017-08-03T08:08:41.313Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/1811036-5c11bf8da7b55777.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="秋千"></p><blockquote class="blockquote-center"><br><br>我们习惯了沉湎于回忆，却忘了自己也在一点一点变旧。沾染尘埃，锈迹了生活。<br><br>听很多的歌，像吸食大量的鸦片。<br><br>震耳欲聋，乐此不疲。<br><br>耳膜在享受着肆虐的快感。心 ，却是寂寂的，不发一语。<br><br>暮色四拢的时候，总有飞机飞过。信号灯明灭着呼啸而去。<br><br>有人沉默的远去了，有人正急切的赶赴一场相聚。<br><br>高空上演绎着起伏的悲欢。<br><br>而我，能做的不过是紧了紧书包。<br><br>转身，面无表情。<br><br>心中沟壑千条，那些人那些事早已不复原貌。<br><br>只是这旧日的影子仍旧在徘徊着，鲜活的不似曾经。<br><br>东风摇百草，四顾何茫茫。<br><br>我是如此怀念亲爱的你们，以及一不小心就不见了的自己。<br><br>那时候烂漫无知的笑啊，胸无城府的小算计呀，傻里傻气的故弄清高。<br><br>沉醉了自己，撞进了谁人的眼里。<br><br>那些扬花三月般的时光，连同无知岁月里的欢笑、泪水。<br><br>就这样，一路跑着，留一串未明的歌谣，面容模糊的远去了。<br><br>当所有的悲伤逆袭而来，我连自嘲的勇气都没有。<br><br>于是，快乐的时候不再快乐，悲伤的时候仍旧悲伤。<br><br>青春，终究是一个人的过场。<br><br>一路丢盔弃甲，一路溃不成军。<br><br>成长，本就如人饮水，冷暖自知。<br><br>亦如人情，本就凉薄。<br><br>全身而退，到底是一种奢求。<br><br>——致面容模糊的过去<br><br><br><br><br><br></blockquote><div id="music163player"><br><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=22453837&auto=1&height=66"></iframe><br></div>]]></content>
    
    <summary type="html">
    
      告别秋千
    
    </summary>
    
    
      <category term="杂七杂八" scheme="http://icessun.github.io/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://icessun.github.io/hello-world.html"/>
    <id>http://icessun.github.io/hello-world.html</id>
    <published>2017-07-19T00:47:31.696Z</published>
    <updated>2017-08-03T09:12:29.150Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h1><p>Welcome to <a href="https://icessun.github.io/">icessun</a></p><a id="more"></a><div id="music163player"><br><br><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=22453837&auto=1&height=66"></iframe><br></div>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;hello-world&quot;&gt;&lt;a href=&quot;#hello-world&quot; class=&quot;headerlink&quot; title=&quot;hello world&quot;&gt;&lt;/a&gt;hello world&lt;/h1&gt;&lt;p&gt;Welcome to &lt;a href=&quot;https://icessun.github.io/&quot;&gt;icessun&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
