<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[纪念我的手机卡]]></title>
      <url>/%E7%BA%AA%E5%BF%B5%E6%88%91%E7%9A%84%E6%89%8B%E6%9C%BA%E5%8D%A1.html</url>
      <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/1811036-fcc55bbcfc01cc7f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="念"></p>
<blockquote>
<p>有人说：手机卡是有灵性的，它可以感受到你所有喜怒哀乐。</p>
</blockquote>
<p>前段时间，换了一个新手机，把玩了一会就把它丢弃在桌子上面，半个月来没有在宠信它；随着计划的旅游日程的到来，我想起来那个新的手机，毕竟我要带你去拍风景哇！于是乎，便翻了它的牌，打开卡槽，奔溃，迷你卡；意味着我得去剪卡，跑到楼下的小店，一问：”剪卡10块”，而且态度极其的不好，一种给钱就给你办，不给钱就滚远点的态度，钱是小事，这种态度受不了，潇洒的转身，夺门而出，指着我的新手机的卡槽，骂道：“打死你个龟孙，让我受这气”。</p>
<p>回到楼上，坐在床上深呼吸，脑海蹦出自己剪卡的想法，想到就干，拿起剪刀，在手机卡上面比划几下，完成。装入新手机一试，意料之中的结果出现了—–无法识别SM卡，手机卡废了。</p>
<p>这张卡已经用了差不多5年，从大学开始就一直在用。第一次拿到这张卡的时候，卡里面赠送了50块大洋，那个时候年少无知，单纯的像一个白纸，忘记了有长途漫游，结果一不小心打了10来分钟电话，手机就停机了，而且还欠了一些，现在想起来觉得好傻；后来，我去哪里，都会带着它。见证了我的友情，亲情，爱情；也看见了我的笑容和眼泪；一切非生命的东西，待的时间久了，终会萌生一些情感，因为这是你记忆承载的地方。</p>
<p>于是乎，一个失误，判其死刑；呜呼，悲哉！</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1811036-7ec84ce8156636d0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="海"></p>
<p>别人说：手机给了我一种安全感，要是手机没电了，会觉得整个人都不好了。</p>
<p>我尝试不带手机出门，去上班。在这一天里面，我发现我并没有像手机在旁边一样去玩手机，有时候走起路来，口袋里面没有一个手机的重量压着，会感觉走路都快人一步；不可思议，这肯定是错觉，哈哈哈哈！</p>
<p>一些事情，平常看起来不起眼，感觉就是生活中的一部分，那天不做了，会感觉到无比的落寞和空虚。如同一年前的我，每次都会打开微信刷朋友圈，然后关掉；不一会又打开，关掉；突然一天良心发现，我要是关闭朋友圈，我的生活会怎么样呢？一边想着，一边关掉了朋友圈。一开始的时候，打开微信还是会下意识的点开发现按钮，当看到朋友圈已经不出现在里面的时候，又把微信给关掉了，一来二去，便把朋友圈关了有一年之久。</p>
<p>其实在没有朋友圈的日子里面，你会发现生活也没有多大的变化，只是自己玩微信的时候变短了，相对有更多的时间去干其他感兴趣的事情，仅此而已。没有花过多的时间去关注别人的生活，当想起一个朋友的时候，点开他的朋友圈看看就行。点不点的开，那就看你的人品啦！</p>
<p>那张手机卡，是我迷茫青春的见证，虽然判你死刑，但是会为你立个墓碑。感谢你的陪伴！</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1811036-e2f9c43f3fc881d0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="雪"></p>
<blockquote>
<p>墓志铭：一生终于一人，远方的电话未接。<br>  猝于：丁酉鸡年 己酉月 丁酉日  白露<br>享年：1859天</p>
</blockquote>
<div id="music163player"><br><br>   <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=22453837&auto=1&height=66"></iframe><br><br></div>
]]></content>
      
        <categories>
            
            <category> 杂七杂八 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 杂七杂八 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Canvas解读]]></title>
      <url>/Canvas%E8%A7%A3%E8%AF%BB.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><code>HTML5</code>新增的元素，可以在页面上使用<code>JavaScript</code>来控制，画出图形。</p>
</blockquote>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li>首先要创建一个画布</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 宽高是属性，不要设置在style中，否者会发生变形  canvas闭合标签 </span></div><div class="line">&lt;<span class="selector-tag">canvas</span> id=<span class="string">'myCanvas'</span> <span class="attribute">width</span>=<span class="string">'800'</span> height=<span class="string">'800'</span>&gt;当浏览器不支持Canvas的时候，写入的文字&lt;/canvas&gt;</div></pre></td></tr></table></figure>
<ul>
<li><p>然后获取渲染的上下文 </p>
<ul>
<li>无论是绘制那种图形，都要经过这步；每一个画布都有一个渲染的上下文对象，使用<code>getContext()</code>方法获取，传入的参数<code>2d/webgl</code>：前者表示是平面图案，后者是立体图案<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// js代码</span></div><div class="line"><span class="keyword">var</span> myCanvas=<span class="built_in">document</span>.getElementById(<span class="string">'myCanvas'</span>);</div><div class="line"><span class="keyword">if</span>(myCanvas.getContext)&#123;</div><div class="line">   <span class="keyword">var</span> ctx=myCanvas.getContext(<span class="string">'2d'</span>);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>最后开始绘制</p>
<ul>
<li>操作我们获取的渲染上下文这只画笔，由点到线再到面<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"> ctx.benginPath(); <span class="comment">// 开始绘制路径，拿起了笔了</span></div><div class="line"> ctx.moveTo(<span class="number">20</span>,<span class="number">20</span>); <span class="comment">// 设置绘制路径的起点，相当于画布的坐标（20，20）</span></div><div class="line"> ctx.lineTo(<span class="number">200</span>,<span class="number">20</span>); <span class="comment">// 绘制了一条直线，到坐标（200，20）的直线</span></div><div class="line"> ctx.lineWidth=<span class="number">1.0</span>; <span class="comment">// 设置线宽</span></div><div class="line"> ctx.lineCap=<span class="string">"button"</span>; <span class="comment">//设置端点样式:butt(默认),round,square</span></div><div class="line"> ctx.lineJoin=<span class="string">"miter"</span>;  <span class="comment">//设置连接样式:miter(默认),bevel,round</span></div><div class="line"> ctx.strokeStyle=<span class="string">"#ff0000"</span>; <span class="comment">// 设置线的颜色</span></div><div class="line"> ctx.stroke();  <span class="comment">// 进行线的着色，这时整条线才变得可见</span></div><div class="line"> ctx.closePath(); <span class="comment">//自动绘制一条当前点到起点的直线，形成一个封闭图形</span></div><div class="line"> </div><div class="line"><span class="comment">//填充</span></div><div class="line">ctx.fillStyle='red'; <span class="comment">// 通过fillStyle来改变填充颜色</span></div><div class="line">ctx.fill(); <span class="comment">// 填充</span></div><div class="line"></div><div class="line"><span class="comment">// 先闭合了，再填充</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><code>beginPath</code>方法表示开始绘制路径，<code>moveTo(x, y)</code>方法设置线段的起点，<code>lineTo(x, y)</code>方法设置线段的终点，<code>stroke</code>方法用来给透明的线段着色；否则，在画布里面看不到东西。</p>
<h3 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ctx.fillStyle = 'yellow'; <span class="comment">// 给矩形填充颜色，默认是黑色</span></div><div class="line">ctx.fillRect(<span class="number">50</span>, <span class="number">50</span>, <span class="number">200</span>, <span class="number">100</span>);</div></pre></td></tr></table></figure>
<p><code>fillRect(X,Y,width,height)</code>里面的四个参数表示：矩形距离画布的位置坐标(x,y)，矩形自己的宽度和高度(width,height)，其绘制的是一个实心的图形；<br>一定是先填充颜色，在绘制矩形，要不然无法给矩形填充颜色。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ctx.strokeRect(<span class="number">10</span>,<span class="number">10</span>,<span class="number">200</span>,<span class="number">100</span>);</div></pre></td></tr></table></figure>
<p><code>strokeRect()</code>方法与上一个类似，但是是绘制空心矩形。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ctx.clearRect(<span class="number">100</span>,<span class="number">50</span>,<span class="number">50</span>,<span class="number">50</span>);  <span class="comment">// 清除某个矩形区域的内容</span></div></pre></td></tr></table></figure></p>
<h3 id="绘制弧形"><a href="#绘制弧形" class="headerlink" title="绘制弧形"></a>绘制弧形</h3><blockquote>
<p>通过这个方法，可以绘制圆</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ctx</span><span class="selector-class">.arc</span>(<span class="selector-tag">x</span>, <span class="selector-tag">y</span>, <span class="selector-tag">radius</span>, <span class="selector-tag">startAngle</span>, <span class="selector-tag">endAngle</span>, <span class="selector-tag">anticlockwise</span>);</div></pre></td></tr></table></figure>
<p>圆心坐标（x，y）相当于画布的坐标；半径:radius；扇形的起始角度和终止角度(startAngle, endAngle,弧度为单位)，是否逆时针：anticlockwise，（true:逆时针；false：顺时针）</p>
<ul>
<li><p>绘制实心圆</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ctx.beginPath();</div><div class="line">ctx.arc(<span class="number">60</span>，<span class="number">60</span>，<span class="number">50</span>，<span class="number">0</span>，Math.<span class="literal">PI</span>*<span class="number">2</span>,true);</div><div class="line">ctx.fillStyle=<span class="string">"#000"</span>;</div><div class="line">ctx.fill();</div></pre></td></tr></table></figure>
</li>
<li><p>绘制空心圆</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ctx.beginPath(); </div><div class="line">ctx.arc(<span class="number">60</span>, <span class="number">60</span>, <span class="number">50</span>, <span class="number">0</span>, Math.<span class="literal">PI</span>*<span class="number">2</span>, true); </div><div class="line">ctx.lineWidth = <span class="number">1.0</span>; </div><div class="line">ctx.strokeStyle = <span class="string">"#000"</span>; </div><div class="line">ctx.stroke();</div></pre></td></tr></table></figure>
</li>
</ul>
<div id="music163player"><br><br>   <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=22453837&auto=1&height=66"></iframe><br><br></div>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> canvas </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[screenX / Y，clientX / Y和pageX / Y之间有什么区别?]]></title>
      <url>/screenX-Y%EF%BC%8CclientX-Y%E5%92%8CpageX-Y%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB.html</url>
      <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/1811036-623f95e3ed6518a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图|网络"></p>
<a id="more"></a>
<h3 id="offsetX，offsetY"><a href="#offsetX，offsetY" class="headerlink" title="offsetX，offsetY"></a>offsetX，offsetY</h3><blockquote>
<p><code>IE浏览器</code>特有的事件属性<br>鼠标点击的位置相当于<code>事件源元素</code>的位置坐标，以元素盒子模型的内容区域的左上角为参考点</p>
</blockquote>
<h3 id="clientX，clientY"><a href="#clientX，clientY" class="headerlink" title="clientX，clientY"></a>clientX，clientY</h3><blockquote>
<p>设置或获取鼠标指针位置相对于<code>浏览器视口（内容区域的左上角）</code>的坐标，与浏览器是否有滚动条无关<br>相对于页面的可见部分的左上角，通过浏览器窗口“看到”。<br>相对于<code>viewport</code>CSS像素的坐标。</p>
</blockquote>
<h3 id="screenX，screenY"><a href="#screenX，screenY" class="headerlink" title="screenX，screenY"></a>screenX，screenY</h3><blockquote>
<p>设置或获取获取鼠标指针位置相对于<code>物理屏幕的左上角</code>的坐标，当改变屏幕的<code>分辨率</code>的时候，坐标会随之改变<br>相对于<code>screen</code>设备像素的坐标。</p>
</blockquote>
<ul>
<li>对于这个属性<code>probably never need</code></li>
</ul>
<h3 id="pageX，pageY"><a href="#pageX，pageY" class="headerlink" title="pageX，pageY"></a>pageX，pageY</h3><blockquote>
<p>相对于浏览器中完<code>全呈现的内容区域</code>的左上角，此参考点位于左上方的网址栏和后退按钮下方。如果在页面中嵌入可嵌入的可滚动页面，并且用户移动滚动条，则可以实际改变位置。<br>坐标相对于整个渲染页面的左上角（包括滚动隐藏的部分）<br>相对于<code>&lt;html&gt;</code>CSS像素中元素的坐标。</p>
</blockquote>
<ul>
<li>pageX与clientX的区别</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1811036-510a2fbcd5bb2d17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="pageY和clientY的差异，图来自网络"></p>
<p>也就是说，当浏览器没有滚动条的时候，pageX和clientX是一样的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(</div><div class="line">    <span class="string">'page: '</span> + e.pageX + <span class="string">','</span> + e.pageY,</div><div class="line">    <span class="string">'client: '</span> + e.clientX + <span class="string">','</span> + e.clientY,</div><div class="line">    <span class="string">'screen: '</span> + e.screenX + <span class="string">','</span> + e.screenY)</div><div class="line">&#125;, <span class="literal">false</span>);</div></pre></td></tr></table></figure>
<p><a href="https://stackoverflow.com/questions/6073505/what-is-the-difference-between-screenx-y-clientx-y-and-pagex-y?rq=1" target="_blank" rel="external">参考资料1</a><br><a href="https://www.quirksmode.org/dom/w3c_cssom.html#t03" target="_blank" rel="external">参考资料2</a></p>
<div id="music163player"><br><br>   <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=22453837&auto=1&height=66"></iframe><br><br></div>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[游记-香港]]></title>
      <url>/%E6%B8%B8%E8%AE%B0-%E9%A6%99%E6%B8%AF.html</url>
      <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/1811036-5111813fbf88752d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="维港夜景"></p>
<a id="more"></a>
<p> 一直说去香港，去香港，这次终于去了！去了就觉得应该写点什么，那样给自己留点回忆，以后也能回忆点啥。总结一下自己香港之行的收获：</p>
<ol>
<li>香港的生活节奏还是挺快的</li>
<li>自己的英语口语太菜了，粤语也听不懂，只能笑笑不说话的尴尬</li>
<li>方向感比较差，容易迷路</li>
</ol>
<h4 id="前奏"><a href="#前奏" class="headerlink" title="前奏"></a>前奏</h4><p>终于跟别人约好去香港了，高兴的前几天都做噩梦，尴尬！第一次去，查找各种攻略，感觉他们写的都差不多，无非都是吃喝玩乐，所以我给自己定下了一些不同：</p>
<ol>
<li>感受当地的叫卖文化；</li>
<li>感受港大的校园文化；</li>
</ol>
<p>事前准备：八达通（余额足），境外流量，送关服务，港澳通行证（用不到身份证），雨伞，充电宝，400左右的港币零钱，纸巾，背包，用于消费的银行卡或者支付宝；这些做好了就可以出发啦！</p>
<h4 id="上午"><a href="#上午" class="headerlink" title="上午"></a>上午</h4><p>跟同学商量，选择了<code>深圳湾口岸</code>出关，就是因为这个地方离他那边比较近，早上可以多睡会，到了口岸，人真多，太多了，由于是第一次过关，所以要去找淘宝上面买的过关服务服务点，拿着一张纸，选择团队旅游通道排队，将近花了一个小时的时候，才过关，过关后也有港币兑换的地方，比外面的汇率高一些，可以多兑换一点。然后我们坐着大巴，通过深圳湾大桥，来到了屯门市中心，这一趟，花了港币11块，然后想着去坐地铁去<code>旺角</code>，香港迷一般的天桥，方向感不好的这个时候你可能就迷路了，买的流量卡老是定位不准，结果找到了在地面上面跑的轻轨，轻轨站台没有屏蔽门，没有安检员，没有售票处，只是在站台上有几个可以刷八达通的机器，一些路线图。<img src="http://upload-images.jianshu.io/upload_images/1811036-a0f8100b5b5a79f7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屯门">误打误撞终于找到了地铁，然后乘坐地铁来到了<code>铜锣湾</code>，找了一个地方（稻香超级渔港）吃早茶—–其实到了的时候差不多11点半了，算是我们的早午餐；用四个字形容这次的早茶：<code>嫩，酥，滑，鲜</code>；现点现做，人又多，吃了我们将近2个小时的时候，吃完一个盘子，服务员立马就给你收走空盘，这节奏似乎催着你快点吃完，快点走，好给别人空出位置来，服务员的说话语速也是特别的快的，下面上图美食图片，这些东西花了250港币：<br><img src="http://upload-images.jianshu.io/upload_images/1811036-40f399ce9ed4e1ac.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="什么煮"><br><img src="http://upload-images.jianshu.io/upload_images/1811036-5449990899a47328.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="菠萝包"><br><img src="http://upload-images.jianshu.io/upload_images/1811036-f0781dfa07c37c23.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="粉丝皮什么卷"><br><img src="http://upload-images.jianshu.io/upload_images/1811036-f347c4905bff116a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="虾带什么球"><br><img src="http://upload-images.jianshu.io/upload_images/1811036-9cd556403741bd5a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="正宗肠粉"><br><img src="http://upload-images.jianshu.io/upload_images/1811036-d84bd884315bb3c0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="芝麻什么卷"></p>
<h4 id="下午"><a href="#下午" class="headerlink" title="下午"></a>下午</h4><p>吃饱喝足了，先把我们准备购买的东西先买了，购物就不详细记录了，反正就买买买，看见好多都是提着旅行箱来的，购物花了差不多2个小时，算是比较快了。<img src="http://upload-images.jianshu.io/upload_images/1811036-83632a58a5488e83.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="高楼林立"><br><img src="http://upload-images.jianshu.io/upload_images/1811036-19fb48c5f508750f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="荷李活中心"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1811036-7fc8b7b1e5a64722.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="砵兰街">，之后，我们一路狂奔，搭乘地铁，来到了尖沙咀，<code>维多利亚港</code>。果然人多，个个都在举着自拍杆拍照，相信大多数人和我一样，除了感受一些维多利亚港湾的徐徐海风和蔚蓝大海，最主要的也是重要的一点，拍个小视频发朋友圈炫耀，然后加一个定位，生怕别人猜不到这是维多利亚港。<img src="http://upload-images.jianshu.io/upload_images/1811036-dbb185d60c0ea7f0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="维多利亚港"><br><img src="http://upload-images.jianshu.io/upload_images/1811036-8d7a5406105cae73.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="维多利亚港">，接着我们搭乘了<code>天星小轮</code>到了维多利亚港对面，没有做过船的小伙伴可以去尝试一下天星小轮，有点意思。一路来到了<code>金紫荆广场</code>，一朵巨大的紫荆花蔚然屹立在维多利亚港旁，<img src="http://upload-images.jianshu.io/upload_images/1811036-c4cb7e4d337a0a93.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="金紫荆广场">，稍微在广场周围休息了会，真的是暴走哇，看看外国美女，匆忙的游客，悠闲的老人，在广场上屌丝一般的玩了一把王者荣耀。差不多到了六点左右，然后直接又奔向铜锣湾吃晚饭。</p>
<h4 id="晚上"><a href="#晚上" class="headerlink" title="晚上"></a>晚上</h4><p>那顿晚上花了差不多500港币，真贵！晚上8点，搭乘巴士来到乘坐<code>山顶缆车</code>方，已经有好多人在那里排队了，没办法啊，不能不去啊，等到了差不多10，我们才坐上了通往<code>太平山</code>顶的缆车，真的是一辆车，带着我们爬山哇，那个坡度，一度引起游客们的尖叫，太陡了，几乎90度。尤其是到了半山腰的时候，看见窗外的维多利亚港的夜景，看夜景，你要坐在车厢的右侧，车内瞬间沸腾了，一度让我出现缆车会掉下去的恐惧感，司机的技术真好。到了山顶，急忙的进入了<code>美杜莎蜡像馆</code>，因为留给我们参观的时间不多了，11点，蜡像馆关门。在里面就是一个劲的跟着这些明星的蜡像合影，瞬间变成了迷弟。<img src="http://upload-images.jianshu.io/upload_images/1811036-302515f59f3e5dac.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="卷福"><br><img src="http://upload-images.jianshu.io/upload_images/1811036-3963a5ff12748119.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="习大大"><br><img src="http://upload-images.jianshu.io/upload_images/1811036-c4dc06186c61306b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="成龙大哥"><br>最后到了<code>凌霄阁</code>看了维多利亚港的夜景，就是开头那张图片，我还在太平山顶帮助维持秩序的安保大叔同声翻译他说的粤语，毕竟之前在他旁边听了好多次，加上自己的理解，翻译的没有毛病，相信很多大陆游客听到香港本地人说粤语，肯定是一脸的蒙蔽，毕竟他们的粤语十级，走之前，那位大叔还感谢我，哈哈哈。</p>
<h4 id="午夜"><a href="#午夜" class="headerlink" title="午夜"></a>午夜</h4><p>从太平山顶下来，已经是凌晨了，<code>中环</code>的街道还是有不少的人，我们商量好去看大陆还没有上映的<code>银河护卫队2</code>，两小时的电影看完，感觉好困啊，走了一天，准备出发去维多利亚港，对，今天是周末，听别人说，一到了周末菲佣会出门聚会，但没想到是在大马路上露天野餐。果然在不远处看见了，吓死了。大半夜的在香港街头浪，你会发现，在一些天桥的上面，桥底都会有人在那睡觉，或者是拿把伞遮挡，或者是全身裹着黑色的衣服，只把眼睛漏出来，不知道是喝醉的，还是一些流浪的，最后走到了一个24小时营业的麦当劳，实在累了，就走进去，吃了点东西，休息。没错，我们没有在香港住旅馆，我们是在香港街头浪，碰见了好多警察叔叔，他们会在半夜出来巡逻，生怕被警察叔叔请出喝茶。在麦当劳里躲避<code>阿sir</code>是一个不错的选择。就这样，我们在麦当劳待了3个小时，到了早上6点，搭乘最早的地铁，出发去<code>将军澳</code>。</p>
<h4 id="早上"><a href="#早上" class="headerlink" title="早上"></a>早上</h4><p>搭乘了最早的一班地铁，香港的地铁，设计很不错，给人一种舒适安宁的环境，一点没有匆忙的感觉。路过了久违的皇后大道；我们打算去将军澳的<code>华人永久坟场</code>，缅怀<code>黄家驹</code>。墓地所在地，面朝的维多利亚港，<br><img src="http://upload-images.jianshu.io/upload_images/1811036-555a0cceb2839dd9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="墓地外景"><br><img src="http://upload-images.jianshu.io/upload_images/1811036-60173e08b7b312c8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="皇后大道"></p>
<p>但是上去是对一个人的考验，很陡，徒步上去肯定是非常的累，我们选择了徒步上去，诚心的缅怀黄家驹。可以看见一抹蓝，那就是黄家驹的墓地所在，本以为我们会是第一个到达，结果上去一看，发现有一个对于我们来说是妈妈级别的粉丝已经在给黄家驹扫墓了，见到我们来了后，张口就说了一句粤语，看见我们很茫然的表情，改口说了很烂的国语：“你们过来给黄家驹鞠躬。”，鞠完躬后，我们就一起帮助她打理墓地，交谈中，我们知道她已经听黄家驹的歌超过30年了，有时间就会来帮忙打理黄家驹的墓地，由于她现在有风湿病，腿脚不方便，现在来的少了，碰见了我们是缘分，一边打理着，一边交代我们，要是你们以后自己来了，应该怎么做，还向我们表达了对一些来到黄家驹墓地拍照，直播的行为的痛斥。她告诉我们，那只在黄家驹墓地上面盘旋的鸟，就是黄家驹的守卫者，我们按照她的吩咐，一丝不苟的忙碌着，墓地被我们打扫的很干净，前前后后花了两个小时，最后和这位年长的老人告别，我们搭乘大巴下山了，太累了。最后我们直接坐地铁到了罗湖，回到了深圳。<img src="http://ww2.sinaimg.cn/large/006HJ39wgy1ffdrbs04jlj30zk0qogn1.jpg" alt="香港地铁"><br>唯一的遗憾是没有去香港大学，希望下次去的时候，我的英语口语变的好一些，香港再会。<br><img src="http://upload-images.jianshu.io/upload_images/1811036-2af058d8272be109.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="标志性建筑"></p>
<div id="music163player"><br><br>   <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=22453837&auto=1&height=66"></iframe><br><br></div>
]]></content>
      
        <categories>
            
            <category> travel </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hong Kong </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[javaScript高级程序设计读书笔记（六）]]></title>
      <url>/javaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89.html</url>
      <content type="html"><![CDATA[<blockquote>
<p>面向对象的程序设计，面向对象的语言有类的概念，通过类创造多个具有相同的属性和方法的对象。</p>
</blockquote>
<a id="more"></a>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h4><ul>
<li>数据属性：包含一个数据值的位置，可以读取和写入<ul>
<li><code>[[Configurable]]</code>：是否可以delect删除属性</li>
<li><code>[[Enumerable]]</code>：是否可以for-in循环对象</li>
<li><code>[[Writable]]</code>：是否可以修改属性的值</li>
<li><code>[[Value]]</code>：属性的数据值</li>
</ul>
</li>
<li>访问器属性：不包含数据值，包含下面两个函数<ul>
<li><code>getter</code></li>
<li><code>setter</code></li>
</ul>
</li>
</ul>
<p>####创建对象</p>
<blockquote>
<p>以前使用的创建对象的方法（直接new Object和字面量），有明显的缺点：会出现大量冗余的代码。</p>
</blockquote>
<h5 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h5><blockquote>
<p> 用函数来封装以特定接口创建对象的细节，根据接收的参数来创建一个包含所有必要信息的对象。缺点是无法解决对象识别的问题，就是怎么知道一个对象的类型。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">creatPerson</span>(<span class="params">name,age,job</span>)</span>&#123;</div><div class="line">   <span class="keyword">var</span> o=<span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">// 创建一个对象</span></div><div class="line">   o.name=name;</div><div class="line">   o.age=age;</div><div class="line">   o.job=job;</div><div class="line">   o.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">       <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> o;  <span class="comment">// 返回这个创建的对象</span></div><div class="line"> &#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> preson=creatPerson(<span class="string">'icessun'</span>,<span class="number">18</span>,<span class="string">'sofeware engineer'</span>)</div></pre></td></tr></table></figure>
<h5 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h5><blockquote>
<p>Object和Array这样原生的构造函数，在运行时会自动出现在执行环境中，也可以自定义构造函数，可以直接创建对象。使用构造函数重写工厂模式代码，有以下不同：</p>
<ul>
<li>没有显示的创建对象</li>
<li>直接将属性和方法赋给this对象</li>
<li>没有return语句</li>
</ul>
<p>问题：每个实例都重复的创建方法，包含了不同的Function实例，导致不同的作用域链和标识的解析，person1和person2中的方法是不相同的。虽然可以在全局定义一个函数，然后在构造函数里面将属性设置为全局的函数，但一个全局函数只能被一个对象调用，物不能尽其所用，也没有封装可言。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.age=age;</div><div class="line">    <span class="keyword">this</span>.name=name;</div><div class="line">    <span class="keyword">this</span>.job=job;</div><div class="line">    <span class="keyword">this</span>.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">     &#125;;</div><div class="line"> &#125;</div><div class="line"> <span class="keyword">var</span> person1=<span class="keyword">new</span> Person(<span class="string">'icessun'</span>,<span class="number">18</span>,<span class="string">"software Enginner"</span>);</div><div class="line"> <span class="keyword">var</span> person2=<span class="keyword">new</span> Person(<span class="string">'icessun1'</span>,<span class="number">19</span>,<span class="string">'student'</span>);</div></pre></td></tr></table></figure>
<p>使用new方式（调用构造函数的方法）创建的对象实例， 会经历下面四步：</p>
<ul>
<li>创建一个新对象</li>
<li>将构造函数的作用域赋给新对象，this就指向这个新对象</li>
<li>执行构造函数中的代码，添加属性和方法</li>
<li>返回新对象</li>
</ul>
<p>这样的每一个实例对象身上都有一个constructor（构造函数）属性，指向Person，可以用来标识对象类型的（特定的类型）；但是检测对象类型一般使用instanceof操作符可靠一些。</p>
<h5 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h5><blockquote>
<p>创建的每一个函数都有一个prototype（原型）属性，指向一个对象；这个对象（原型对象 ）的用途是包含可以由特定类型的所有实例共享的属性和方法。prototype就是通过调用构造函数而创建的实例的原型对象。好处：可以让所有的实例共享原型对象包含的属性和方法，不用在构造函数里面定义实例的信息，而是直接添加到原型对象中。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Person.prototype.constructor------&gt; Person </div><div class="line"><span class="comment">// 空的构造函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 属性和方法都添加到Person的prototype属性中，由实例共享</span></div><div class="line">Person.prototype.name=<span class="string">"icessun"</span>;</div><div class="line">Person.prototype.age=<span class="string">"18"</span>;</div><div class="line">Person.prototype.job=<span class="string">"engineer"</span>;</div><div class="line">Person.prototype.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">     <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line"> &#125;;</div><div class="line"><span class="keyword">var</span> person1=<span class="keyword">new</span> Person(); <span class="comment">// 调用构造函数创建对象实例</span></div><div class="line">preson1.sayName(); <span class="comment">// icessun</span></div><div class="line"><span class="keyword">var</span> person2=<span class="keyword">new</span> Person();</div><div class="line">person2.sayName();<span class="comment">// icessun</span></div><div class="line"></div><div class="line"> <span class="built_in">console</span>.log(person1.sayName == person2.sayName); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<ul>
<li>理解原型对象</li>
</ul>
<blockquote>
<p>创建一个函数就会为该函数创建一个<code>prototype</code>属性，指向函数的原型对象<code>函数.Prototype</code>；所有的原型对象都自动获得一个<code>constructor</code>（构造函数）属性，这个属性包含一个指向<code>prototype</code>属性所在函数的指针。构造函数创建的实例，其内部有一个指针<code>[[Prototype]](或者)__proto__</code>，指向构造函数的原型对象，这个链接是在实例和构造函数的原型对象之间的。</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/1811036-4b8b7a5e218b66cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="原型对象和构造函数和实例对象之间的关系"></p>
<p>Person.prototype指向原型对象，而Person.prototype..constructor有指向Person。原型对象中除了包含constructor属性之外，还包括后来添加的其他属性。Person的实例都包含一个内部属性指向Person.prototype，与构造函数没有直接的关系。在所有的实现中都无法访问到[[Prototype]]，但是可以通过isPrototypeOf()方法来确定对象之间是否存在这种关系，如果[[Prototype]]指向调用isPrototypeOf()方法(ECMAScript 5中新方法：Object.getPrototypeOf())的对象（Person.prototype），那就返回true</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">console.<span class="built_in">log</span>(person.prototype.isPrototypeOf(person1)) //<span class="literal">true</span> </div><div class="line">console.<span class="built_in">log</span>(person.prototype == Object.getPrototypeOf(person1)) //<span class="literal">true</span> </div><div class="line">console.<span class="built_in">log</span>(Object.getPrototypeOf(person1).name);// icessun  Object.getPrototypeOf(person1) 直接返回<span class="string">[[Prototype]]</span>的值</div></pre></td></tr></table></figure>
<blockquote>
<p>当查找对象的属性时，现在实例找，没有找到才去原型对象上面找；可以通过实例对象访问保存在原型中的值，但是却不能通过对象实例重写原型中的值，当与原型中的属性同名的时，会自动屏蔽原型中的属性。对象实例可以访问到原型对象上<code>constructor</code>属性，使用<code>delete 实例属性</code>可以删除实例的属性，重新访问原型上面的属性；</p>
</blockquote>
<h6 id="确定属性是在原型对象上面还是实例对象上面"><a href="#确定属性是在原型对象上面还是实例对象上面" class="headerlink" title="确定属性是在原型对象上面还是实例对象上面"></a>确定属性是在原型对象上面还是实例对象上面</h6><ul>
<li><code>hasOwnProperty()</code>可以检测一个属性是存在与实例中，还是存在原型中。属性存在实例对象里面就返回<code>true</code></li>
<li><code>in操作符</code>：对象能够访问给定属性的时候，返回<code>true</code>，无论属性是在原型还是实例上；<code>属性  in   对象 // 只要存在就返回 true</code></li>
</ul>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span>  <span class="title">hasPrototypeProperty</span>(object,name)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">!object.hasOwnProperty(name)</span> &amp;&amp; (name <span class="keyword">in</span> object);</div><div class="line">    // 返回<span class="literal">false</span> 就是实例属性  否者是原型属性</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<ul>
<li>为了更好的减少输入，我们可以使用一个对象字面量来表示整个原型对象</li>
</ul>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">()</span><span class="comment">&#123;&#125;</span>;</span></div><div class="line"></div><div class="line"><span class="comment">// 把Person.prototype设置为一个以字面量的形式创建的一个新对象，重写了默认的原型对象prototype对象</span></div><div class="line">Person.prototype=<span class="comment">&#123;</span></div><div class="line">   name:'icessun',</div><div class="line">   age:18,</div><div class="line">   job:'Engineer',</div><div class="line">   sayName:function()&#123;</div><div class="line">      console.log(this.name);</div><div class="line">    &#125;,</div><div class="line">    <span class="function"><span class="keyword">constructor</span>:</span>Person;  <span class="comment">// 解决`constructor`属性不再指向`Person函数`的问题，但是会导致constructor属性可以枚举</span></div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>但是这种方法的<code>constructor</code>属性不再指向<code>Person函数</code>，前面说过，每创建一个函数，就会同时创建它的原型对象<code>prototype对象</code>，而这个对象也会自动获取<code>constructor属性</code>。这方法的<code>constructor</code>属性指向新对象的<code>constructor属性，指向Object构造函数</code>，通过<code>constructor</code>属性无法确定对象的类型</p>
<h6 id="原型的动态性"><a href="#原型的动态性" class="headerlink" title="原型的动态性"></a>原型的动态性</h6><blockquote>
<p>实例获取原型对象上的属性和方法的时候，是一次查找过程；所以在原型对象上面的修改，都能够立即在实例上面反映出来。即使是先创建实例后修改原型对象也是一样的。</p>
</blockquote>
<ul>
<li>实例和原型之间的松散链接关系，连接是一个指针。</li>
<li>调用构造函数的时候，会为实例添加一个指向最初原型的指针<code>[[protorype]]</code>，要是把原型修改为另外一个对象就切断了实例与原型对象的最初的连接。</li>
<li>实例中的指针仅仅指向原型，而不是构造函数</li>
</ul>
<h6 id="原生对象的原型"><a href="#原生对象的原型" class="headerlink" title="原生对象的原型"></a>原生对象的原型</h6><blockquote>
<p>通过原生对象的原型，不仅可以取得所有默认方法的引用，而且也可以定义新的方法。可以向自定义对象的原型引用修改原生对象的原型，可以随时添加方法</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.prototype找到sort（）方法</div><div class="line"><span class="built_in">String</span>.prototype找到substring（）方法</div><div class="line"></div><div class="line">为基本的包装类型<span class="built_in">String</span>添加自定义方法</div><div class="line"></div><div class="line"><span class="built_in">String</span>.prototype.start=<span class="function"><span class="keyword">function</span>(<span class="params">text</span>)</span>&#123;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.indexOf(text) == <span class="number">0</span>; <span class="comment">// 传入的字符串位于一个字符串的开始 返回true</span></div><div class="line"> &#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> msg=<span class="string">'icess un'</span>;</div><div class="line"><span class="built_in">console</span>.log(msg.start(<span class="string">'icess'</span>)); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h6 id="原型对象的问题"><a href="#原型对象的问题" class="headerlink" title="原型对象的问题"></a>原型对象的问题</h6><ul>
<li>原型模型省略了为构造函数传递初始化参数的环节，所有实例默认的获取相同的属性值。</li>
<li>原型中的属性是被很多实例共享的，对于函数来说是方便的，对于包含基本值的属性，给实例添加一个同名的属性，就可以隐藏原型上面的属性。但是对<code>引用类型的属性值</code>来说不行，修改了会在其他的实例里面反映出来。</li>
</ul>
<h5 id="组合使用构造函数模式和原型模式-重点"><a href="#组合使用构造函数模式和原型模式-重点" class="headerlink" title="组合使用构造函数模式和原型模式  (重点)"></a>组合使用构造函数模式和原型模式  (重点)</h5><blockquote>
<p>创建自定义类型的最常见的方式；构造模式用于定义实例属性，原型模式用于定义方法和共享的属性。每一个实例都有一份实例属性的副本，并且同时共享着对方法的引用，最大限度节省内存，还支持向构造函数传递参数。</p>
</blockquote>
<ul>
<li>重写上面的例子</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 构造函数  定义实例的属性</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</div><div class="line">   <span class="keyword">this</span>.name=name;</div><div class="line">   <span class="keyword">this</span>.age=age;</div><div class="line">   <span class="keyword">this</span>.job=job;</div><div class="line">   <span class="keyword">this</span>.friends=[<span class="string">'icessun1'</span>,<span class="string">'icessun2'</span>]; <span class="comment">// 引用类型</span></div><div class="line"> &#125;</div><div class="line"></div><div class="line"><span class="comment">// 原型对象  定义共享的方法 constructor属性</span></div><div class="line"></div><div class="line">Person.prototype=&#123;</div><div class="line">    <span class="attr">constructor</span>:Person, </div><div class="line">    <span class="attr">sayName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">       <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1=<span class="keyword">new</span> Person(<span class="string">'icessun'</span>,<span class="number">18</span>,<span class="string">'engineer'</span>);</div><div class="line"><span class="keyword">var</span> person2=<span class="keyword">new</span> Person(<span class="string">'icessun2'</span>,<span class="number">19</span>,<span class="string">'engineer'</span>);</div><div class="line"></div><div class="line">person1.friends.push(<span class="string">'ben'</span>); <span class="comment">// 引用的不同的数组</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person1.friends); <span class="comment">// icessun1 icessun2 ben</span></div><div class="line"><span class="built_in">console</span>.log(person2.friends); <span class="comment">// icessun1 icessun2</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person1.friends === person2.friends); <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(person1.sayName === person2.sayName);  <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h5 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h5><blockquote>
<p>把所有的信息都封装在构造函数中，通过在构造函数中初始化原型，保持了同时使用构造函数和原型的优点。可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// 构造函数  </span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</div><div class="line">   <span class="keyword">this</span>.name=name;</div><div class="line">   <span class="keyword">this</span>.age=age;</div><div class="line">   <span class="keyword">this</span>.job=job;</div><div class="line">   <span class="keyword">this</span>.friends=[<span class="string">'icessun1'</span>,<span class="string">'icessun2'</span>]; <span class="comment">// 引用类型</span></div><div class="line"></div><div class="line">  <span class="comment">// 方法  IF 检查的可以是初始化之后应该存在的任何属性和方法</span></div><div class="line">   </div><div class="line">   <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">'function'</span>)&#123;</div><div class="line">       Person.prototype.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">   </div><div class="line"> &#125;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> person1=<span class="keyword">new</span> Person(<span class="string">'icessun'</span>,<span class="number">18</span>,<span class="string">'engineer'</span>);</div><div class="line">  person1.sayName();</div></pre></td></tr></table></figure>
<p>只有在<code>sayName()方法不存在的时候</code>，才会将这个方法添加到原型上，只会在初次调用构造函数的时候才会执行。<code>这里对原型的修改，会立即在所有实例中得到反映。</code>，这就导致不能使用字面量重写原型，因为会切断现有实例和新原型之间的联系。可以使用instanceof操作符来确定它的类型。</p>
<h5 id="寄生构造函数模式-（重点）"><a href="#寄生构造函数模式-（重点）" class="headerlink" title="寄生构造函数模式 （重点）"></a>寄生构造函数模式 （重点）</h5><blockquote>
<p>基本思想：创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后在返回新创建的对象。为对象创建构造函数。比如<code>想创建一个具有额外方法的数组</code>。<br>返回的对象与构造函数或者构造函数的原型属性之间没有关系；构造函数返回的对象与在构造函数外部创建的对象实例没有什么不同，是一样的，不能使用instanceof来确定对象类型。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这个函数创建一个新的对象 并且初始化了对象 返回了这个对象</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> o =<span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">    o.name=name;</div><div class="line">    o.age=age;</div><div class="line">    o.job=job;</div><div class="line">    o.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">     &#125;;</div><div class="line">     <span class="keyword">return</span> o;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person=<span class="keyword">new</span> Person(<span class="string">'icessun'</span>,<span class="number">18</span>,<span class="string">'Engineer'</span>);</div><div class="line">person.sayName(); <span class="comment">// 'icessun'</span></div></pre></td></tr></table></figure>
<p>除了使用new操作符并且把包装函数叫做构造函数之外，这个模式和工厂模式是一模一样的。构造函数在不返回值的情况下，默认会返回新对象的实例；但是返回值的话，可以重写调用构造函数时返回的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyArray</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">// 创建数组对象</span></div><div class="line">    <span class="keyword">var</span> values=<span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line">    <span class="comment">// 添加值，初始化数组的值  接收构造函数收到的所有参数</span></div><div class="line">    values.push.apply(values,<span class="built_in">arguments</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 添加方法</span></div><div class="line">    values.toJoin=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.join(<span class="string">'|'</span>);</div><div class="line">     &#125;;</div><div class="line">   </div><div class="line">    <span class="comment">// 返回值</span></div><div class="line">    <span class="keyword">return</span> values;</div><div class="line"> &#125;</div><div class="line"> <span class="keyword">var</span> colors=<span class="keyword">new</span> MyArray(<span class="string">'red'</span>,<span class="string">'blue'</span>,<span class="string">'green'</span>);</div><div class="line"> <span class="built_in">console</span>.log(colors.toJoin());  <span class="comment">// 'red|bule|green'</span></div></pre></td></tr></table></figure>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><blockquote>
<p><code>ECMAScript</code>只支持实现继承，主要依靠原型链来实现继承</p>
</blockquote>
<h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><blockquote>
<p><code>基本思想</code>： 利用原型让一个引用类型继承另外一个引用类型的属性和方法。</p>
</blockquote>
<ul>
<li><p>原型与实例的关系</p>
<blockquote>
<p>每一个构造函数都有一个原型对象<code>prototype</code>，原型对象都包含一个指向构造函数的指针<code>constructor</code>，而实例都包含一个指向原型对象的内部指针<code>__proto__</code></p>
</blockquote>
</li>
<li><p>原型链基本概念</p>
<blockquote>
<p>让一个原型对象等于另一个类型的实例，此时的原型对象将包含一个指向另一个原型的指针，相应的，另一个原型中也包含一个指向另一个构造函数的指针，如此，层层递进，就实现了实例与原型的链条。</p>
</blockquote>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 一个属性和方法</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.property=<span class="literal">true</span>;</div><div class="line"> &#125;</div><div class="line"></div><div class="line">SuperType.prototype.getSuperValue=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.property;</div><div class="line"> &#125;;</div><div class="line"> </div><div class="line"><span class="comment">// 一个属性和方法</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</div><div class="line">     <span class="keyword">this</span>.subproperty=<span class="literal">false</span>;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"><span class="comment">// 原型链继承</span></div><div class="line"><span class="comment">// 继承 SuperType  创建SuperType的实例，将其赋给SubType.prototype实现继承</span></div><div class="line">SubType.prototype=<span class="keyword">new</span> SuperType();</div><div class="line"></div><div class="line">SubType.prototype.getSubValue=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</div><div class="line"> &#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> instance =<span class="keyword">new</span> SubType();</div><div class="line"><span class="built_in">console</span>.log(instance.getSuperValue());  <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>这段代码继承实现的本质是<code>重写原型对象</code>，使其为一个新类型的实例。原来存在<code>SuperType</code>的实例中的所有方法和属性，现在都存在<code>SubType.prototype</code>中了。所以这个重写的原型对象，不但有指向<code>SuperType</code>的实例中的所有方法和属性的指针，还有一个指向<code>SuperType</code>的原型指针<code>__proto__</code>.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1811036-4f8c39bc25cb69d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="实例，构造函数，原型之间的关系"></p>
<ul>
<li>默认的原型<blockquote>
<p>所有函数的默认原型都是<code>Object</code>的实例，因此默认的原型都包含一个内部指针，指向<code>Object.prototype</code>，也就是自定义类型都会继承<code>toString(),valueOf()</code>等默认方法的根本原因。</p>
</blockquote>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1811036-9a30cd0de4551e3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="上面例子的完整原型链图"></p>
<ul>
<li><p>确定原型和实例的关系</p>
<ul>
<li><code>instanceof</code>操作符</li>
</ul>
<blockquote>
<p>主要这个操作符测试的实例与原型链出现过的构造函数，就返回<code>true</code></p>
</blockquote>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(instance  <span class="keyword">instanceof</span>  SubType);  <span class="regexp">//</span> <span class="literal">true</span></div></pre></td></tr></table></figure>
<ul>
<li><p><code>isPrototype()</code>方法</p>
<blockquote>
<p>只要原型链出现的原型，都可以说是该原型链所派生的实例的原型，返回<code>true</code> </p>
</blockquote>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">console</span>.log(<span class="type">SubType</span>.proto<span class="keyword">type</span>.isProtype(instance));  // true</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>子类重写父类里面的方法，是在原型上面修改的，这段代码一定要放在替换原型的语句后面。</p>
</li>
<li>通过原型链实现的继承，不能使用<code>对象字面量创建原型方法</code>，因为会重写原型链</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 原型链继承</span></div><div class="line">SubType.prototype=<span class="keyword">new</span> SuperType();</div><div class="line"></div><div class="line"><span class="comment">// 对象字面量创建原型方法 会导致上一行代码无效 </span></div><div class="line">SubType.prototype=&#123;</div><div class="line">   <span class="attr">getSubValue</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">someOtherMathod</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">     &#125;</div><div class="line"> &#125;;</div><div class="line"></div><div class="line"> <span class="keyword">var</span> instance=<span class="keyword">new</span> SubType();</div><div class="line"> <span class="built_in">console</span>.log(instance.getSuperValue()); <span class="comment">// error!</span></div></pre></td></tr></table></figure>
<p>因为后面的字面量方式的代码使得原型包含一个<code>Object</code>    实例，不是<code>SuperType</code>实例。</p>
<ul>
<li>原型链的问题<blockquote>
<p>引用类型的问题，引用类型的原型属性会被所有实例共享，也就为什么要在构造函数里面定义属性的原因。通过原型来实现继承的时候，原型实际上会变成另一个类型的实例，故原来的实例属性也就顺理成章的变成现在的原型属性了；还有就是在创建子类型的实例时候，不能向超类的构造函数中传递参数。</p>
</blockquote>
</li>
</ul>
<div id="music163player"><br>   <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=22453837&auto=1&height=66"></iframe><br><br></div>]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git与github学习笔记]]></title>
      <url>/git%E4%B8%8Egithub%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
      <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/1811036-ba75eec40861687e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="工作流图"></p>
<a id="more"></a>
<h2 id="认识Git"><a href="#认识Git" class="headerlink" title="认识Git"></a>认识<code>Git</code></h2><ul>
<li>是一个强大的分布式版本控制工具 </li>
<li>分布式：可以协作，任务可以拆分；每次的改动都有记录，版本可以控制</li>
<li>强大的分支管理</li>
</ul>
<h4 id="直接记录快照，而非差异比较"><a href="#直接记录快照，而非差异比较" class="headerlink" title="直接记录快照，而非差异比较"></a>直接记录快照，而非差异比较</h4><blockquote>
<p>关心文件数据的整体是否发生变化，而非文件内容的具体差异；每一次提交更新，会对所有的文件作一快照，保存一个指向快照的索引，要是文件没有变化，不会再次保存，只是对上次保存的快照作一链接。</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/1811036-37d61b88c4e7ea67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="更新的文件快照"></p>
<h4 id="几乎都是在本地操作"><a href="#几乎都是在本地操作" class="headerlink" title="几乎都是在本地操作"></a>几乎都是在本地操作</h4><blockquote>
<p> <code>Git</code>在本地磁盘上就保存着所有当前项目的历史更新，所有保存在 <code>Git</code> 数据库中的东西都是用哈希值(<code>SHA-1</code> 校验和)来作索引的，而不是靠文件名。在保存到  <code>Git</code> 之前，所有数据都要进行内容的校验和（checksum）计算，并将此结果作为数据的唯一标识和索引。</p>
</blockquote>
<h4 id="文件的三种状态"><a href="#文件的三种状态" class="headerlink" title="文件的三种状态"></a>文件的三种状态</h4><ul>
<li>已修改（本地仓库进行<code>add</code>）</li>
<li>已暂存（暂存区域<code>staging area  commit</code>）</li>
<li>已提交（<code>git</code>工作目录 ）<br>-<code>git</code>工作目录 ：用来保存元数据和对象数据库的地方。该目录非常重要，每次克隆镜像仓库的时候，实际拷贝的就是这个目录里面的数据。<ul>
<li>如果 <code>git clone</code> 出来的话，<code>Git</code> 目录就是其中<code>.git</code> 的目录；如果<code>git clone --bare</code> 的话，新建的目录本身就是<code>Git</code> 目录</li>
</ul>
</li>
</ul>
<h2 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a><code>Git</code>安装</h2><ul>
<li><p><code>windows</code>上面安装</p>
<ul>
<li>直接下载<code>msysgit</code><a href="https://git-for-windows.github.io" target="_blank" rel="external">软件</a></li>
<li>开始菜单里面找到<code>Git</code>—-&gt;<code>Git Bash</code>，或者在一个文件夹上面鼠标右键，选择<code>Git Bash</code>，出现类似命令行窗口，说明安装成功</li>
<li><p>配置</p>
   <figure class="highlight verilog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">     <span class="comment">//在命令行里面输入下面两句，进行配置</span></div><div class="line">        $ git <span class="keyword">config</span> --<span class="keyword">global</span> user<span class="variable">.name</span> <span class="string">"Your Name"</span></div><div class="line">        $ git <span class="keyword">config</span> --<span class="keyword">global</span> user<span class="variable">.email</span> <span class="string">"email@example.com"</span>     </div><div class="line"></div><div class="line"><span class="comment">// 配置差异分析工具</span></div><div class="line">$ git <span class="keyword">config</span> --<span class="keyword">global</span> merge<span class="variable">.tool</span> vimdiff</div><div class="line"></div><div class="line"> <span class="comment">// 查看git配置信息</span></div><div class="line">       $ git <span class="keyword">config</span> --list</div><div class="line"> <span class="comment">// 获取帮助</span></div><div class="line"> $ git help &lt;verb&gt;</div></pre></td></tr></table></figure>
<ul>
<li>在全局配置了用户名和<code>Email</code>地址，就是以后电脑上面的所有仓库都是使用这个配置</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><ul>
<li>使用<code>git</code>窗口创建一个文件夹</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> mkdir 文件名 //创建这个文件名</span></div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> 文件名 // 进入到这个文件名</span></div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">pwd</span>  // 查看这个文件所在的目录</span></div></pre></td></tr></table></figure>
<ul>
<li>接着初始化一个<code>Git</code>仓库</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 首先应该进入到创建的文件夹目录下</div><div class="line"><span class="meta">$</span><span class="bash"> git init</span></div><div class="line">初始化后，在当前的目录下面会出现一个.git的文件夹，所有 Git 需要的数据和资源都存放在这个文件夹中</div><div class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> url // 默认是克隆下来的项目名字的文件夹作为项目的文件夹</span></div><div class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> url 自定义文件夹名字  // 使用自己自定义的文件夹作为项目目录的文件夹</span></div></pre></td></tr></table></figure>
<blockquote>
<p>版本库初始化之后，就在本地默认创建了<strong>主分支</strong> <code>master</code>，用来发布重大的版本，日常开发在这个主分支上面开辟一条<strong>开发分支</strong>来操作，然后合并到主分支上面</p>
</blockquote>
<ul>
<li>当然也可以直接在你想在的目录下面（确保这个目录下面没有中文，否则出错），鼠标右键新建一个文件夹，然后鼠标右键选择<code>Git　Bash</code>，输入<code>git　init</code></li>
</ul>
<h2 id="文件保存在仓库"><a href="#文件保存在仓库" class="headerlink" title="文件保存在仓库"></a>文件保存在仓库</h2><ul>
<li>然后把我们需要保存在仓库的文件，直接拖到我们刚才创建的仓库的文件夹下，然后打开<code>Git</code>命令窗口，输入下面的命令，使里面的文件纳入到版本控制，进行跟踪</li>
</ul>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">$</span> git add &lt;<span class="keyword">file</span>&gt;  <span class="comment">// 把文件添加到仓库 暂存区</span></div><div class="line"><span class="symbol">$</span> git commit -m <span class="string">'描述'</span>  <span class="comment">// 文件提交到仓库 保存一个版本的快照 保存在版本历史记录里面</span></div><div class="line"></div><div class="line"><span class="symbol">$</span> git commit -a -m <span class="string">'描述'</span> <span class="comment">// 直接跳过暂存区，把所有已经跟踪过的文件暂存起来一起提交</span></div><div class="line"></div><div class="line"><span class="comment">// 漏掉的文件没有加入，或者提交的消息写错了 修改最后一次提交 如果刚才提交完没有作任何改动，直接运行此命令的话，相当于有机会重新编辑提交说明，但将要提交的文件快照和之前的一样。</span></div><div class="line"><span class="symbol">$</span> git commit --amend </div><div class="line"></div><div class="line"></div><div class="line"><span class="symbol">$</span> git rm 要删除的文件 <span class="comment">// 该文件就不会纳入版本管理，要是这个删除文件，已经修改并且放到了暂存区的话，就必须强制删除 -f</span></div><div class="line"></div><div class="line"><span class="symbol">$</span> git rm --cached 不跟踪的文件 <span class="comment">// 把文件从跟踪清单里面删除</span></div><div class="line"></div><div class="line"><span class="comment">// 重新命名文件</span></div><div class="line"><span class="symbol">$</span> git mv file_from  file_to</div></pre></td></tr></table></figure>
<ul>
<li>当然可以使用<code>$ git add *</code>来提交所有的文件</li>
<li>当我们更改了文件，使用<code>$ git status</code>可以查看我们更改的那个文件，这个命令是让我们时刻了解当前仓库的状态，以及那些文件被添加到了暂存区，那些文件没有被添加<ul>
<li>可以使用<code>$ git diff</code>来查看具体修改了什么地方，是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容，若要看已经暂存起来的文件和上次提交时的快照之间的差异，可以用<code>git diff --cached</code> 命令。更高版本还允许使用<code>git diff --staged</code>，效果是相同的，但更好记些。</li>
<li>要把修改后的文件，提交到仓库，继续上面的两个命令<code>add 和 commit</code></li>
<li>此时在运行<code>$ git status</code>，就会提示，当前没有需要提交的修改，工作目录干净<code>working directory clean</code></li>
</ul>
</li>
</ul>
<h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><ul>
<li><code>commit</code>命令是在仓库里面保存我们一个版本的快照，所有后面跟的说明文件很重要，我们可以使用<code>$ git log</code>来查看我们保存的版本历史记录，通过描述文件更快的知道，然后通过历史记录回退到以前的版本</li>
</ul>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">$</span> git <span class="built-in">log</span> <span class="comment">// 从最近的到最远的版本记录</span></div><div class="line"> </div><div class="line"><span class="symbol">$</span> git <span class="built-in">log</span> -p <span class="number">-2</span> <span class="comment">// -p 展示每次提交的内容差异 -2 最近两条 </span></div><div class="line"></div><div class="line"><span class="symbol">$</span> git <span class="built-in">log</span> --pretty=oneline  --graph <span class="comment">// 输出的信息更简短   --graph  多出一些 ASCII 字符串表示的简单图形，形象地展示了每个提交所在的分支及其分化衍合情况。</span></div></pre></td></tr></table></figure>
<ul>
<li>此时我们可以从输出的信息看到<code>commit id</code> ，是一连串的由<code>sha1</code>计算出来并且以16进制表示的数字，这个数字是我们回退到以前版本的版本号</li>
<li>在<code>git</code>中，使用<code>HEAD</code>表示当前版本，也就是上面输出信息的第一个，上一个版本就是<code>HEAD^</code>，上上个版本就是<code>HEAD^^</code>，以此类推，n个前的版本就是<code>HEAD~n</code></li>
<li>回退到上一个版本，使用下面命令，然后输出<code>HEAD is now at commit id号 说明信息</code>，查看仓库的文件，已经恢复到上一个版本了</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> git reset --hard HEAD^</span></div></pre></td></tr></table></figure>
<ul>
<li>此时在次输入<code>$　git　log</code>，我们会发现，前一个版本不见了，只有我们现在的版本和现在版本之前的版本，要是我们还是需要回到前一个版本呢，这个时候<code>commit id</code>就发挥作用了，在当前的窗口向上查找前一个版本的<code>commit id</code>号，然后输入<code>$ git reset --hard commit id号，不需要输入完整的</code></li>
<li>当我们不小心关闭了窗口，找不到了前一个版本的id的时候，我们可以使用<code>$ git reflog</code>来查找，查看命令历史</li>
</ul>
<h2 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h2><h3 id="工作区"><a href="#工作区" class="headerlink" title="工作区"></a>工作区</h3><ul>
<li>就是我们创建的仓库</li>
</ul>
<h3 id="版本库"><a href="#版本库" class="headerlink" title="版本库"></a>版本库</h3><ul>
<li>在工作区里面隐藏了一个<code>.git</code>文件，这个是版本库</li>
<li>版本库里面有暂存区<code>stage</code>，还有自动创建的第一个分支<code>master</code>，以及指向这个分支的指针<code>HEAD</code></li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/1811036-6cb8ec5cf370a38b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="git add 工作"></p>
<ul>
<li>前面说道通过<code>add 和 commit -m</code>把文件添加到版本库里面</li>
</ul>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">$</span> git add  * <span class="comment">//把修改的文件添加到暂存区</span></div><div class="line"><span class="symbol">$</span> git commit -m <span class="comment">// 把暂存区的内容提交到当前的分支（master），没有创建其他分支的情况下</span></div></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/1811036-c1ab7fa3fdc5a116.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="git commit 工作"></p>
<ul>
<li>如果不<code>add</code>到暂存区，那就不会加入到<code>commit</code>中</li>
<li><code>Git</code>管理的是修改，而不是文件；也就是说，每一次修改的时候，都要先<code>add</code>，然后在<code>commit</code></li>
</ul>
<h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><blockquote>
<p>什么时候会出现修改撤销呢？我们在工作区修改文件错误；或者已经<code>add</code>提交了，把错误也提交了暂存区；在或者<code>commit</code>把错误提交到了版本库</p>
</blockquote>
<h3 id="在工作区撤销修改，没有add之前"><a href="#在工作区撤销修改，没有add之前" class="headerlink" title="在工作区撤销修改，没有add之前"></a>在工作区撤销修改，没有<code>add</code>之前</h3><ul>
<li>发现错误及时，可以直接手动把错误删除</li>
<li>要是错误太多，也可以使用命令<code>$ git checkout -- &lt;file&gt;</code>，来撤销修改，丢弃工作区的修改</li>
</ul>
<h3 id="add之后，commit之前"><a href="#add之后，commit之前" class="headerlink" title="add之后，commit之前"></a><code>add</code>之后，<code>commit</code>之前</h3><ul>
<li>取消已经暂存的文件，回到已经修改但未暂存的文件</li>
<li>这个时候，使用这个命令，可以撤销暂存区的修改，重新放回到工作区<code>$ git reset HEAD &lt;file&gt;</code></li>
<li>退回到工作区，我们接着可以使用<code>$git checkout -- &lt;file&gt;</code>来撤销工作区的修改</li>
</ul>
<h3 id="commit之后，提交到了版本库，没有推送到远程"><a href="#commit之后，提交到了版本库，没有推送到远程" class="headerlink" title="commit之后，提交到了版本库，没有推送到远程"></a><code>commit</code>之后，提交到了版本库，没有推送到远程</h3><ul>
<li>这个时候，我们只能<strong>回退版本</strong>了，前提是你没有把版本库提交到远程，否则是修改不了了</li>
</ul>
<h3 id="远程仓库github"><a href="#远程仓库github" class="headerlink" title="远程仓库github"></a>远程仓库<code>github</code></h3><ul>
<li>访问<a href="https://github.com/" target="_blank" rel="external">github</a>官网注册帐号，参考<a href="https://guides.github.com/activities/hello-world/" target="_blank" rel="external">资料</a></li>
<li>由于本地仓库和远程仓库是靠<code>ssh</code>加密传输的，所以首先要创建<code>SSH KEY</code>，打开用户主目录，一般是这样的地址<code>C:\Documents and Settings\Administrator</code>，查看是否有一个<code>.ssh</code>的文件，可能文件夹被隐藏，应该在文件夹选项里面设置显示隐藏文件，有的话，直接打开，复制<code>id_rsa.pub（公钥）</code>里面的内容，登入<code>github</code>网站，打开<code>account settings</code>，选择<code>SSH KEYS</code>页面，然后点击<code>Add SSH KEY</code>，把复制的内容粘贴到里面就行</li>
<li>要是主目录下面没有，打开<code>git</code>命令窗口，创建SSK KEY；<code>$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code></li>
<li>然后在远程仓库里面创建一个仓库，在本地仓库里面使用下面命令和远程仓库建立链接：<code>$ git remote add origin git@github.com:icessun/icessun.github.io.git // 添加远程仓库</code>，远程库的名字默认<code>origin</code></li>
<li>推送本地仓库的文件到远程库中</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> git push origin master / 远程仓库的名字  分支的名字</span></div><div class="line"><span class="meta">$</span><span class="bash"> git remote show 远程仓库的名字 // 查看远程仓库的信息</span></div><div class="line"><span class="meta">$</span><span class="bash"> git remote rename 原远程仓库的名字  现在仓库的名字 // 修改某个远程仓库在本地的简称</span></div><div class="line"><span class="meta">$</span><span class="bash"> git remote rm 远程仓库的名字  // 碰到远端仓库服务器迁移，或者原来的克隆镜像不再使用，又或者某个参与者不再贡献代码，那么需要移除对应的远端仓库，</span></div></pre></td></tr></table></figure>
<ul>
<li>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。以后每次提交只需要<code>$ git push origin master</code></li>
</ul>
<ul>
<li>查看当前配置了那些远程仓库</li>
</ul>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">$</span> git remote <span class="comment">// 查看配置了那些远程仓库</span></div><div class="line"></div><div class="line"><span class="symbol">$</span> git remote -v <span class="comment">// 显示对应的克隆地址  </span></div><div class="line"></div><div class="line"><span class="comment">// 如果是克隆了一个仓库，此命令会自动将远程仓库归于 origin 名下。 </span></div><div class="line"><span class="symbol">$</span> git fetch origin  <span class="comment">// 会抓取从你上次克隆以来别人上传到此远程仓库中的所有更新（或是上次 fetch 以来别人提交的更新）</span></div><div class="line"></div><div class="line"><span class="symbol">$</span> git fetch 远程仓库名 <span class="comment">// 拉取本地仓库没有的信息 从远程仓库抓取数据到本地 并不自动合并到当前工作分支</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>克隆远程仓库</strong><code>$ git clone git@github.com:icessun/icessun.github.io.git</code></li>
</ul>
<blockquote>
<p><code>git clone</code> 命令本质上就是自动创建了本地的 <code>master</code>分支用于跟踪远程仓库中的 <code>master</code> 分支；运行 <code>git pull</code>，目的都是要从原始克隆的远端仓库中抓取数据后，合并到工作目录中的当前分支。</p>
</blockquote>
<h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><blockquote>
<p>使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作；切换分支之前要保存当前分支的工作区是干净的，把修改提交，否则不让你切换分支</p>
</blockquote>
<ul>
<li>创建分支：<code>$ git branch 分支的名字</code></li>
<li>切换分支：<code>$ git checkout 分支的名字</code><figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 上面两个命令合并成为一条</span></div><div class="line"> <span class="symbol">$</span> git checkout -b 分支的名字</div><div class="line"></div><div class="line"> <span class="symbol">$</span> git branch -v <span class="comment">// 查看各个分支最后一个提交对象的信息</span></div><div class="line"> </div><div class="line"> <span class="symbol">$</span> git branch --merged <span class="comment">// 查看哪些分支已被并入当前分支，也就是说哪些分支是当前分支的直接上游。</span></div><div class="line"></div><div class="line">  <span class="symbol">$</span> git branch --<span class="keyword">no</span>-merged <span class="comment">// 查看尚未合并的工作</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/1811036-cf10ad8782bbf5dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建分支testing"></p>
<p><code>HEAD</code>指向当前工作的分支，也可以说是当前分支的别名，<code>HEAD</code>会随着当前工作分支的变化而变化，每提交一次，<code>HEAD</code>向前走动一次</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1811036-c7cbd04c0d0c6675.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="切换到新建的分支上面"></p>
<p>在当前新建的分支上面提交后，会向前移动了一格，而<code>master</code>分支仍然指向原先 <code>git checkout</code>时所在的 <code>commit</code> 对象。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1811036-d8be59b377236c97.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在新建的分支上面提交"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/1811036-f772fd796b75f803.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="切换到主分支上面"></p>
<p>在当前分支上面再次提交，项目提交历史产生了分叉；因为刚才我们创建了一个分支，转换到其中进行了一些工作，然后又回到原来的主分支进行了另外一些工作。这些改变分别孤立在不同的分支里：我们可以在不同分支里反复切换，并在时机成熟时把它们合并到一起。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1811036-a2184c59fda15d32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="项目提交历史出现分叉"></p>
<ul>
<li>查看当前的分支：<code>$ git branch</code>，当前的分支会出现一个<code>*</code>号</li>
<li>把当前分支合并到主分支上面：<code>$ git merge 要合并的分支</code>，合并到<code>master</code>分支上面，合并分支前要切换到要合并的分支上面</li>
</ul>
<p>由于当前 master 分支所指向的提交对象<code>（C4）</code>并不是 <code>iss53</code>分支的直接祖先，Git 不得不进行一些额外处理。就此例而言，Git 会用两个分支的末端<code>（C4 和 C5）</code>以及它们的共同祖先<code>（C2）</code>进行一次简单的三方合并计算。用红框标出了<code>Git</code>用于合并的三个提交对象：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1811036-a895f2357b36eac1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="分支的合并"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/1811036-7355bcfa08d7aa04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="合并后"></p>
<h4 id="合并出现冲突"><a href="#合并出现冲突" class="headerlink" title="合并出现冲突"></a>合并出现冲突</h4><ul>
<li>如果在不同的分支中都修改了同一个文件的同一部分，Git 就无法干净地把两者合到一起（译注：逻辑上说，这种问题只能由人来裁决。）<ul>
<li>要看看哪些文件在合并时发生冲突，可以用 git status 查阅</li>
</ul>
</li>
</ul>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="code"> &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span></div><div class="line"><span class="section">&lt;div id="footer"&gt;contact : email.support@github.com&lt;/div&gt;</span></div><div class="line">=======</div><div class="line">&lt;div id="footer"&gt;</div><div class="line"><span class="code">  please contact us at support@github.com</span></div><div class="line">&lt;/div&gt;</div><div class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53</div></pre></td></tr></table></figure>
<p>可以看到<code>=======</code>隔开的上半部分，是 <code>HEAD</code>（即 <code>master</code>分支，在运行<code>merge</code> 命令时所切换到的分支）中的内容，下半部分是在 <code>iss53</code>分支中的内容。</p>
<ul>
<li>删除分支：<code>$ git branch -d 要删除的分支的名字</code></li>
<li>分支合并出现冲突：<code>$ git log --graph --pretty=oneline --abbrev-commit</code>查看分支合并的情况，出现冲突的时候，我们应该手动修改冲突，在提交</li>
<li>合并禁止<code>Fast forward（当前要合并的分支[新]是master分支[老]的直接上游）</code>模式：<code>$ git merge --no-ff -m &#39;描述&#39; 要合并的分支</code>；这样可以保存合并的分支</li>
<li><code>Bug</code>分支：把当前的工作现场隐藏起来：<code>$ git stash</code>；接着和创建分支一样，创建一个临时的bug分支，修改完成之后合并bug分支到master主分支上面，<code>$ git stash list</code>；查看当前的工作区的隐藏列表，恢复工作区：<code>$ git stash pop</code>，继续工作区的任务</li>
<li>每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支；如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -d &lt;分支name&gt;强行删除</code></li>
</ul>
<h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><ul>
<li>在本地克隆远程仓库的时候，自动把本地的master分支和远程的master分支对应起来</li>
<li>查看远程仓库的信息<code>$ git remove -v</code>：就会显示抓取（fetch）和推送（push）的<code>origin（远程仓库默认的名字）</code>地址，没有推送权限是看不到（push）地址</li>
<li>推送分支（把该分支上的所有本地提交推送到远程仓库）：<code>$ git push origin 本地分支的名字</code></li>
<li>当你小伙伴把修改的推送到了远程，而你正好也修改了相同的文件，那么你就必须<code>git pull</code>下来最新的添加，在本地解决冲突合并，在推送到远程，如果<code>pull</code> 下来提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream 本地分支的名字 远程仓库分支的名字。</code></li>
<li>在本地创建和远程分支对应的分支，使用  <code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</li>
</ul>
<h3 id="小窍门"><a href="#小窍门" class="headerlink" title="小窍门"></a>小窍门</h3><p>在 Windows 上安装了<code>msysGit</code>，默认使用的<code>Git Bash</code>就已经配好了这个自动补全脚本，可以直接使用。</p>
<p>在输入<code>Git</code>命令的时候可以敲两次跳格键（Tab），就会看到列出所有匹配的可用命令建议：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git <span class="keyword">co</span><span class="symbol">&lt;tab&gt;</span><span class="symbol">&lt;tab&gt;</span></div><div class="line">commit   config</div></pre></td></tr></table></figure>
<ul>
<li><code>GIT</code>命名别名</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git <span class="keyword">config</span> --<span class="keyword">global</span> <span class="keyword">alias</span><span class="variable">.co</span> checkout</div><div class="line">$ git <span class="keyword">config</span> --<span class="keyword">global</span> <span class="keyword">alias</span><span class="variable">.br</span> branch</div><div class="line">$ git <span class="keyword">config</span> --<span class="keyword">global</span> <span class="keyword">alias</span><span class="variable">.ci</span> commit</div><div class="line">$ git <span class="keyword">config</span> --<span class="keyword">global</span> <span class="keyword">alias</span><span class="variable">.st</span> status</div><div class="line">$ git <span class="keyword">config</span> --<span class="keyword">global</span> <span class="keyword">alias</span><span class="variable">.last</span> 'log -<span class="number">1</span> HEAD' <span class="comment">// 要看最后一次的提交信息 git last</span></div></pre></td></tr></table></figure>
<p>现在，如果要输入 <code>git commit</code>只需键入 <code>git ci</code> 即可</p>
<blockquote>
<p>参考资料<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰网站git教程</a><br><a href="http://iissnan.com/progit/html/zh/ch2_5.html" target="_blank" rel="external">git pro</a></p>
</blockquote>
<div id="music163player"><br><br>   <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=22453837&auto=1&height=66"></iframe><br><br></div>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/hello-world.html</url>
      <content type="html"><![CDATA[<h1 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h1><p>Welcome to <a href="https://icessun.github.io/">icessun</a></p>
<a id="more"></a>
<div id="music163player"><br><br> <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=22453837&auto=1&height=66"></iframe><br></div>



]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[javascript高级程序设计读书笔记（四）]]></title>
      <url>/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89.html</url>
      <content type="html"><![CDATA[<blockquote>
<p>  变量，作用域，和内存的问题</p>
</blockquote>
<a id="more"></a>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><blockquote>
<p>不存在定义一个变量就保存这种数据类型的值的规则，一个变量的值和数据类型可以在脚本的生命周期内改变。</p>
<ul>
<li>基本类型的值</li>
<li>引用类型的值</li>
</ul>
</blockquote>
<h4 id="基本类型的值"><a href="#基本类型的值" class="headerlink" title="基本类型的值"></a>基本类型的值</h4><blockquote>
<p>基本数据类型是<strong>按照值访问的</strong>，可以操作保存在变量里面实际的值</p>
</blockquote>
<ul>
<li>字符串</li>
<li>数值<ul>
<li><code>NaN</code>：特殊的数值型；<code>isNaN()</code>：返回是否是不是数值</li>
<li><code>isNaN()</code>被对象调用的时候，会首先调用对象的<code>valueOf()</code>，看其是否可以转为数值；不能，则基于这个返回值在调用<code>toString()</code>，再看是否是数值</li>
</ul>
</li>
<li>布尔值</li>
<li><code>undefined</code></li>
<li><code>null</code><ul>
<li>只要意在保存的变量还没有真正保存对象，就应该明确的让该变量保存<code>null</code>，体现出<code>null</code>是空对象指针。</li>
</ul>
</li>
</ul>
<blockquote>
<p>字符串，数值和布尔值都有<code>toString()</code>方法，但<code>undefined</code>和<code>null</code>没有此方法，但是可以使用<code>String()</code>，这个方法可以传入<code>基数</code>，输出二进制或者八进制或者十六进制的字符串值</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">转为true的值</th>
<th style="text-align:center">转为false的值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Boolean</td>
<td style="text-align:center">true</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:center">Number</td>
<td style="text-align:center">任何非0数字，包括无穷大</td>
<td style="text-align:center">0和NaN</td>
</tr>
<tr>
<td style="text-align:center">String</td>
<td style="text-align:center">任何非空字符串</td>
<td style="text-align:center">‘ ‘(空字符串)</td>
</tr>
<tr>
<td style="text-align:center">Object</td>
<td style="text-align:center">任何对象</td>
<td style="text-align:center">null</td>
</tr>
<tr>
<td style="text-align:center">Undefined</td>
<td style="text-align:center">不适用</td>
<td style="text-align:center">undefined</td>
</tr>
</tbody>
</table>
<p>在内存中占据固定大小的空间，因此保存在<code>栈内存</code>里面</p>
<h4 id="引用类型的值"><a href="#引用类型的值" class="headerlink" title="引用类型的值"></a>引用类型的值</h4><blockquote>
<p>是保存在内存中的对象，是<strong>按照引用来访问</strong>的，因为，<code>JS</code>是不允许直接访问内存中的位置，也就不能直接操作对象的内存空间，实际上是操作对象的引用 </p>
</blockquote>
<p>引用类型的值是对象，保存在<code>堆内存</code>中</p>
<ul>
<li><code>Object类型</code><blockquote>
<p>对象其实就是数据和功能的集合，<code>Object类型</code>是所有它的实例的基础，其所具有的任何的属性和方法同样都存在更具体的对象中。</p>
</blockquote>
</li>
</ul>
<h4 id="两种值的不同点"><a href="#两种值的不同点" class="headerlink" title="两种值的不同点"></a>两种值的不同点</h4><ul>
<li>当定义一个引用类型的变量，可以为其动态的添加属性和方法，但是基本类型的变量就不可以，虽然操作是不会出现错误，返回<code>undefined</code></li>
<li><p>基本类型的变量的复制</p>
  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var <span class="attribute">num1</span>=5;</div><div class="line">var <span class="attribute">num1</span>=num2;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>num1和num2是<strong>相互独立</strong>的，互不影响，在内存空间里面分配不同的空间</li>
</ul>
<ul>
<li><p>引用类型值的复制：</p>
  <figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1=<span class="keyword">new</span> <span class="type">Person</span>();</div><div class="line"><span class="keyword">var</span> obj2=obj1;</div></pre></td></tr></table></figure>
</li>
<li><p>此时的obj2和obj1是指向同一个地址空间，之间的复制是把引用，也就是指向这个对象的内存空间的<strong>指针复制</strong>了一份，当操作obj1的属性的时候，obj2也受到影响</p>
</li>
</ul>
<h4 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h4><blockquote>
<p><code>ECMAScript</code>中所有函数的参数都是<code>按值传递</code>的。就是把值，从外部的变量，复制一份给函数中参数变量。传递基本类型的值给函数中的参数的时候，被传递的值被复制给函数参数<code>aguments</code>对象的一个元素，局部变量；给参数传递引用类型的时候，就是把这个值在内存中的地址复制给<code>arguments</code>中的一个局部变量，所以这个局部变量变化会反映在函数的外部。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">       obj.name=<span class="string">'icessun'</span>;</div><div class="line">       obj=<span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">       obj.name=<span class="string">'icessun1'</span>;  <span class="comment">//将新的对象赋值给obj对象并设置name属性 </span></div><div class="line">  &#125; </div><div class="line">  <span class="keyword">var</span> person=<span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">  setName(person);</div><div class="line">  alert(person.name);   <span class="comment">// 弹出icessun  这说明参数的传递是按照值来的</span></div></pre></td></tr></table></figure>
<p>上面的代码说明，参数是按照值传递的，因为在函数<code>setName</code>中，重新赋值一个对象给<code>obj</code>，并且改变了其<code>name</code>属性，要是按照引用传递的话，那么后面弹出来的是<code>icessun1</code>；结果却不是这样，这说明：</p>
<blockquote>
<p>函数内部改变了参数的值，但是原始的引用保持不变；因为在函数内部重写参数时，这个变量引用就是一个局部变量，会在函数执行完毕立即销毁。</p>
</blockquote>
<h4 id="类型检测"><a href="#类型检测" class="headerlink" title="类型检测"></a>类型检测</h4><ul>
<li><code>typeof</code><ul>
<li>字符串  ——&gt;    <code>string</code><br><code>var n; console.log(typeof n); // undefined</code></li>
<li>数值   ——-&gt;  <code>number</code></li>
<li>布尔值  ——–&gt; <code>boolean</code></li>
<li><code>undefined</code> ——-&gt; <code>undefined</code></li>
</ul>
</li>
</ul>
<p><code>unll == undefined;      true</code></p>
<blockquote>
<p><code>typeof</code>是检测上面这几种类型的最佳工具，但是对于<code>null</code>和<code>对象</code>都返回<code>object</code>，因为<code>null</code>表示一个空对象指针，所以<code>typeof null</code>为<code>Object</code>；检测函数的时候，会返回<code>function</code>；这是区分函数和其他对象的方法，函数是一个对象，不是一种数据类型。</p>
</blockquote>
<p>对于未声明的变量和为初始化的变量，执行<code>typeof</code>操作都返回<code>undefined</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message; <span class="comment">//  未初始化</span></div><div class="line"><span class="comment">// var age;   未声明</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> message);  <span class="comment">// undefined</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> age);     <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<ul>
<li><code>instanceof</code> ：检测什么类型的对象（引用类型）</li>
</ul>
<blockquote>
<p><code>variable instanceof constructor</code>  返回<code>true/false</code> </p>
</blockquote>
<ul>
<li><code>Object</code></li>
<li><code>Array</code></li>
<li><code>RegExp</code><br>如果变量是给定引用类型的实例，那么<code>instanceof</code>之后返回的结果都是<code>true</code>；基本类型不是对象，都返回<code>false</code>。所有的引用类型的值都是<code>Object</code>的实例。</li>
</ul>
<h4 id="执行环境和作用域"><a href="#执行环境和作用域" class="headerlink" title="执行环境和作用域"></a>执行环境和作用域</h4><blockquote>
<p>执行环境定义了变量和函数有权访问的其他数据。决定了各自的行为。某个执行环境中的所有代码执行完毕，该环境就被销毁，保存在里面的所有的变量和函数定义也随之销毁。每个函数都有自己的执行环境，当执行这个函数的时候，会把这个函数推入到一个环境栈里面，直到函数执行完成，再从环境栈里面弹出，交到之前的执行环境。</p>
</blockquote>
<ul>
<li>作用域链<ul>
<li>保证对执行环境有权访问的所有变量和函数的有序访问；其前端，始终是当前执行代码的所在环境的变量对象<code>环境是函数，则这个活动对象就是arguments对象</code>。下一个变量对象来自包含环境（包含当前变量对象的外部环境），就这样一直延续到全局执行环境，故全局的执行环境是作用域链的最后一个对象。</li>
</ul>
</li>
</ul>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="built_in">color</span>=<span class="string">'blue'</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">color</span>===<span class="string">'blue'</span>)&#123;</div><div class="line">         <span class="built_in">color</span>=<span class="string">'red'</span>;</div><div class="line">     &#125;<span class="title">else</span>&#123;</div><div class="line">         <span class="built_in">color</span>=<span class="string">'blue'</span>;</div><div class="line">      &#125;</div><div class="line"> &#125;</div><div class="line"> changeColor();</div><div class="line"> <span class="built_in">console</span>.log(<span class="string">'Color is now'</span>+<span class="built_in">color</span>);</div></pre></td></tr></table></figure>
<p>上面的代码中，函数的作用域链包含两个对象：自己的变量对象<code>arguments对象</code>和全局环境的变量对象。可以在函数内部访问到全局的变量，因为在其的作用域链上面可以找到。<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">作用域链： </div><div class="line">    -<span class="ruby"> window</span></div><div class="line">       -<span class="ruby"> color</span></div><div class="line">       -<span class="ruby"> changeColor()</span></div><div class="line">          -<span class="ruby"> arguments</span></div></pre></td></tr></table></figure></p>
<p>  每一个环境都可以向上搜索作用域链，查询变量和函数名，但是不能向下搜索作用域链；函数参数也是函数执行环境中内部的变量，局部变量。</p>
<ul>
<li><p>延长作用域链</p>
<ul>
<li><code>try-catch语句</code>中的<code>catch块</code></li>
<li><code>with语句</code></li>
</ul>
</li>
<li><p><code>没有块级作用域</code></p>
<blockquote>
<p>在其他的类<code>C</code>语言，由花括号封闭的代码块都有自己的作用域，因而支持根据条件来定义变量。但是<code>JavaScript</code>没有块级作用域</p>
</blockquote>
<ul>
<li><p>声明变量</p>
<blockquote>
<p>使用<code>var</code>声明的变量会自动添加到<code>最接近的环境中</code>：在函数内部，最接近的就是函数的局部环境；在<code>with</code>语句中，最接近的是函数环境；如果初始化变量时没有使用<code>var</code>，则会自动把该变量添加到全局环境中。</p>
</blockquote>
<ul>
<li><strong>注意</strong>：<br>在<code>javascript</code>中，由<code>for</code>语句创建的变量<code>i</code>（由<code>var</code>声明的），即使循环结束，也依旧存在循环外部的执行环境中。</li>
</ul>
</li>
<li><p>作用域向上搜索</p>
<p>在执行环境中查找一个变量的时候，在局部环境里面找到，就直接使用；否者，继续向上的作用域链查找，没有找到，说明该变量没有声明。</p>
</li>
</ul>
</li>
</ul>
<h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><blockquote>
<p><code>javascript</code>中有自动垃圾回收机制；原理就是：找到那些不再需要继续使用的变量，然后释放其占用的内存。垃圾回收机制会按照固定的时间间隔，周期性的去执行这一操作。</p>
</blockquote>
<ul>
<li>标记清除<br> 给存储在内存中的变量都加上标记，然后去掉环境中的变量标记以及被环境中的变量引用的变量的标记；之后再加上的标记的变量是当做准备删除的变量，因为环境中的变量已经无法访问到这些变量了；最后，垃圾回收器完成垃圾的回收。</li>
<li>计数清除<br>  记录每一个值被引用的次数，当声明了一个变量并将一个引用类型赋值给该变量的时候，引用次数为1，如果同一个值又被赋给其他的变量，该值引用次数就加1，包含对这个值引用的变量又取得另外一个值，则这个值的引用次数减1，当次数为0的时候就说明不能访问到，应该回收；<strong>坏结果</strong>：循环引用。</li>
</ul>
<p><code>IE9</code>把<code>BOM</code>和<code>DOM</code>对象都转换成真正的<code>JavaScript</code>对象。就避免了垃圾回收的问题，也消除了常见的内存泄漏现象。</p>
<p>一般来说：一旦数据不再使用，最好手动将其设置为<code>null</code>，来释放其引用，适合大多数的全局变量和全局对象的属性。局部变量会在离开执行环境的时候自动解除引用。解除引用，是让值脱离执行环境，等待垃圾回收运行将其回收。</p>
<div id="music163player"><br>   <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=22453837&auto=1&height=66"></iframe><br><br></div>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[javascript高级程序设计读书笔记（五）]]></title>
      <url>/javascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89.html</url>
      <content type="html"><![CDATA[<blockquote>
<p>  引用类型</p>
</blockquote>
<p>对象是某个特定的引用类型的实例。新对象是使用<code>new</code>操作符后跟一个构造函数来创建的。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> preson=<span class="keyword">new</span> <span class="built_in">Object</span>();</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a><code>Object</code>类型</h3><ul>
<li><p>创建对象的方法</p>
<ul>
<li><code>new</code>+构造函数 ：<code>var preson=new Object()</code></li>
<li><p>对象字面量 ：向函数传递大量<code>可选参数</code>的首选方式</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var <span class="keyword">person</span>=&#123;</div><div class="line">           name:'icessun',    &lt;=====&gt;var <span class="keyword">person</span>=&#123; &#125;;</div><div class="line">           age:18</div><div class="line">   &#125;</div><div class="line"></div><div class="line">访问对象的属性：<span class="keyword">person</span>.属性；<span class="keyword">person</span><span class="comment">[属性]</span>，【】一般是通过变量来访问属性</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="Array类型"><a href="#Array类型" class="headerlink" title="Array类型"></a><code>Array</code>类型</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors=<span class="keyword">new</span> <span class="type">Array</span>();  里面可以写入一个数值，表示数组的长度<span class="keyword">new</span> <span class="type">Array</span>(<span class="number">20</span>)；也可以直接在里面写入数组的值<span class="keyword">new</span> <span class="type">Array</span>(<span class="string">'red'</span>,<span class="string">'blue'</span>,<span class="string">'green'</span>)</div><div class="line"></div><div class="line">字面量方式：</div><div class="line"><span class="keyword">var</span> colors=[<span class="string">'red'</span>,<span class="string">'blue'</span>,<span class="string">'green'</span>]  <span class="comment">//不会调用Array的构造函数</span></div></pre></td></tr></table></figure>
<ul>
<li><p>检测数组</p>
<ul>
<li><code>instanceof</code><ul>
<li>是在单一的全局执行环境中检测数组，对于从一个执行环境中传递到另一个执行环境中的数组是检测不出来的</li>
</ul>
</li>
<li><code>Array.isArray()</code><ul>
<li>这个方法确定某个值到底是不是数组，而不管是在哪个全局执行环境创建的</li>
</ul>
</li>
</ul>
</li>
<li><p>转换方法</p>
<blockquote>
<p>所有的对象都具有<code>toLocaleString(),toString(),valueOf()</code></p>
</blockquote>
<ul>
<li><code>toString()</code>：默认是用<code>逗号</code>隔开返回数组的每个值的字符串</li>
<li><code>join([分隔符])</code>：使用不同的分隔符来返回数组每个值的字符串</li>
</ul>
</li>
<li><p>数组中的栈方法</p>
<blockquote>
<p>后进先出(LIFO)的数据结构，栈中项的插入和删除只发生在—-栈的顶部。</p>
</blockquote>
<ul>
<li><code>push()</code><ul>
<li>传入要在数组末尾添加的数据，返回修改后数组的长度</li>
</ul>
</li>
<li><code>pop()</code><ul>
<li>删除数组末尾的最后一项（取得数组中的最后一项），返回被删除的项</li>
</ul>
</li>
</ul>
</li>
<li><p>数组中的队列方法</p>
<blockquote>
<p>先进先出(FIFO)的数据结构，在队列的末端添加项，在队列的 前端移除项。</p>
</blockquote>
<ul>
<li><code>shift()</code><ul>
<li>移除数组中的第一个项，并且返回移除的项，同时将长度减1</li>
<li>结合<code>push()</code>方法，可以实现队列操作</li>
</ul>
</li>
<li><code>unshift()</code><ul>
<li>在数组的前端添加多个项并且返回修改后数组的长度；结合<code>pop()</code>方法，可以实现队列操作</li>
</ul>
</li>
</ul>
</li>
<li><p>数组中的重排序方法</p>
<ul>
<li><code>reverse()</code><ul>
<li>只是把数组颠倒个顺序，并不会对齐排序，返回经过排序的数组</li>
</ul>
</li>
<li><p><code>sort()</code></p>
<ul>
<li><p>默认是按照升序排列数组；其默认会调用每一个数组项的<code>toString()</code>转为<code>字符串进行比较</code></p>
   <figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var num1=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>]</div><div class="line">num1.sort() ; <span class="comment">//     [0, 1, 10, 15, 5]</span></div></pre></td></tr></table></figure>
<p>   这个方法不是我们需要的排序方法，所以一般在里面传递一个比较函数</p>
   <figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num=[<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>];</div><div class="line">num.sort(<span class="function"><span class="keyword">function</span><span class="params">(a,b)</span></span>&#123;</div><div class="line">         <span class="keyword">return</span> a-b;  <span class="comment">// 从小到大</span></div><div class="line">         <span class="keyword">return</span> b-a; <span class="comment">// 从大到小</span></div><div class="line">   &#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>操作数组的方法</p>
<ul>
<li><p><code>concat()</code>：连接多个数组的方法</p>
<ul>
<li>先会创建当前数组的一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新创建的数组；</li>
<li>没有传递参数，就是<code>复制当前的数组</code>，返回当前数组的副本</li>
<li>传递参数，就是把参数插入在当前的数组的副本的末尾,连接多个数组，返回修改的数组</li>
</ul>
</li>
<li><p><code>slice()</code></p>
<ul>
<li>一个参数：返回从该参数指定的位置开始到当前数组的末尾的所有项，数组的形式返回。</li>
<li>两个参数：返回起始位置到结束位置之间的项，但是不包括结束位置的项。<code>包前不包后</code></li>
<li>不影响原数组，可以传入负数，加上数组长度来计算</li>
<li>不传参数的时候，就是<code>复制原数组</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><code>splice()</code></li>
</ul>
<blockquote>
<p>主要用途就是向数组中部插入项，返回一个数组，该数组包含从原始数组删除的项，没有就返回一个空数组</p>
</blockquote>
<ul>
<li><code>删除</code>：可以删除任意数量的项<ul>
<li><code>splice(删除的第一项，要删除的项数)</code></li>
</ul>
</li>
<li><p><code>插入</code>：在指定位置插入任意项</p>
<ul>
<li><code>splice(插入起始位置，0，要插入的项（可以多个）)</code></li>
</ul>
</li>
<li><p><code>替换</code>：在指定位置插入任意项</p>
<ul>
<li><code>splice(起始位置，删除的项，要插入的项)</code></li>
</ul>
</li>
</ul>
<ul>
<li><p>位置方法</p>
<ul>
<li><code>indexOf(要查找的项，[开始查找起点位置的索引])</code>：开头找，找到返回，没有找打返回-1，严格相等</li>
<li><code>lastIndexOf(要查找的项，[开始查找起点位置的索引])</code>：结尾找，但是返回的索引值还是从前面数</li>
</ul>
</li>
<li><p>迭代方法</p>
<blockquote>
<p>接收两个参数，要在数组的每一个项上面运行的函数和（可选的）运行该函数的作用域对象—影响<code>this</code>的值，函数参数都接收三个参数：数组项的值，该项在数组中的索引值，数组对象本身</p>
</blockquote>
<ul>
<li><code>every()</code>：如果该函数参数对每一项都返回true，则返回true</li>
<li><code>filter()</code>：会返回true的项组成的数组</li>
<li><code>forEach()</code>：没有返回值，本质和for循环迭代数组一样</li>
<li><code>map()</code>：返回每次函数调用返回的结果组成的函数</li>
<li><code>some()</code>：函数参数对某一项返回true，则返回true</li>
</ul>
</li>
</ul>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> numbers=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</div><div class="line"><span class="keyword">var</span> everyR=numbers.every(<span class="function"><span class="keyword">function</span><span class="params">(item,<span class="keyword">index</span>,<span class="keyword">array</span>)</span><span class="comment">&#123;</span></span></div><div class="line">      return (item&gt;2);</div><div class="line">  &#125;)</div><div class="line"><span class="title">console</span>.<span class="title">log</span><span class="params">(everyR)</span>;  <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> someR=numbers.some(<span class="function"><span class="keyword">function</span><span class="params">(item,<span class="keyword">index</span>,<span class="keyword">array</span>)</span><span class="comment">&#123;</span></span></div><div class="line">        return (item&gt;2);</div><div class="line"> &#125;)</div><div class="line"> <span class="title">console</span>.<span class="title">log</span><span class="params">(someR)</span>;  <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> filterR=numbers.filter(<span class="function"><span class="keyword">function</span><span class="params">(item,<span class="keyword">index</span>,<span class="keyword">array</span>)</span><span class="comment">&#123;</span></span></div><div class="line">      return (item&gt;2);</div><div class="line"> &#125;)</div><div class="line"> <span class="title">console</span>.<span class="title">log</span><span class="params">(filterR)</span>; <span class="comment">// [3,4,5,4,3]</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> mapR=numbers.map(<span class="function"><span class="keyword">function</span><span class="params">(item,<span class="keyword">index</span>,<span class="keyword">array</span>)</span><span class="comment">&#123;</span></span></div><div class="line">      return (item*2);</div><div class="line"> &#125;)</div><div class="line"> <span class="title">console</span>.<span class="title">log</span><span class="params">(mapR)</span>;  <span class="comment">// [2,4,6,8,10,8,6,4,2]</span></div></pre></td></tr></table></figure>
<h3 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a><code>Date</code>类型</h3><blockquote>
<p>1970年1月1日开始经过的毫秒数</p>
</blockquote>
<ul>
<li><p>创建一个日期对象 ：<code>var now=new Date()</code></p>
<ul>
<li>没有传入参数：自动获取当前时间和日期</li>
<li>传入参数：<code>var someDate=new Date(&#39;8/1/2017&#39;)</code>，后台调用<code>Date.parse()</code>转化，获取到2017年8月1号的毫秒数</li>
</ul>
</li>
<li><p>继承的方法</p>
<ul>
<li><code>toLocaleString()</code><ul>
<li>按照浏览器的设置时区返回日期和时间</li>
</ul>
</li>
<li><code>toString()</code><ul>
<li>返回带有时区信息的日期和时间</li>
<li>与上一个方法其实没有什么差别，显示时间来说</li>
</ul>
</li>
<li><code>valueOf()</code><ul>
<li>返回日期的毫秒数，可以用来比较日期值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h4><ul>
<li><code>toDateString()</code>：以特定格式显示星期，月，日，年</li>
<li><code>toTimeString()</code>：以特定格式显示时，分，秒，时区</li>
<li><code>toLocalDateString()</code></li>
<li><code>toLocalTimeString()</code></li>
<li><code>toUTCString()</code></li>
</ul>
<h3 id="RegExg-类型"><a href="#RegExg-类型" class="headerlink" title="RegExg()类型"></a><code>RegExg()</code>类型</h3><blockquote>
<p>支持正则表达式  <code>var expression= /pattren/flags</code><br><code>pattren模式：</code><br><code>flags标志：</code>g全局，i不区分大小写，m多行模式，到达一行文本末尾还会继续查找下一行中是否存在</p>
</blockquote>
<ul>
<li>元字符<blockquote>
<p>转义，匹配的字符串里面包含元字符的话<br> <code>{ [ \ ^ $ | ] ? * + .} ( )</code></p>
</blockquote>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1811036-7311264906caafc1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="字面量转字符串"></p>
<ul>
<li><p>创建正则表达式的方法</p>
<ul>
<li>字面量<ul>
<li><code>var pattern=/\.at/gi</code>：匹配所有的<code>.at</code>不区分大小写</li>
</ul>
</li>
<li><code>RegExp()函数</code><ul>
<li><code>var pattern=new RegExp(&#39;[bc]at&#39;,&#39;i&#39;)</code>：接收字符串形式的匹配字符，和标志，里面不能直接使用字面量，</li>
</ul>
</li>
<li><code>区别：ECMAScript3中</code><ul>
<li>字面量始终会共享同一个<code>RegExp()实例</code>，而构造函数创建的每一个新的<code>RegExp实例</code>都是一个新的实例</li>
</ul>
</li>
</ul>
</li>
<li><p><code>RegExp</code>实例方法</p>
<ul>
<li><p><code>exec()</code></p>
<ul>
<li>捕获数组</li>
<li>一个参数：应用模式的字符串</li>
<li>返回值：匹配的数组<code>额外的属性：input（应用正则表达式的字符串） index（匹配项字符串中的位置）/null</code></li>
<li>当在匹配的字符串里面带有<code>g全局模式的时候</code>，每次调用<code>exec()</code>都会返回字符串中的下一个匹配项，直到结尾。<code>lastIndex</code>每次都会增加</li>
</ul>
</li>
<li><p><code>test()</code></p>
<ul>
<li>接收一串字符串</li>
<li>返回true/fasle</li>
</ul>
</li>
<li><p><code>toString()</code>和<code>toLocaleString()</code></p>
<ul>
<li>返回正则表达式的字面量</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Function类型"><a href="#Function类型" class="headerlink" title="Function类型"></a><code>Function类型</code></h3><blockquote>
<p>函数是对象，每一个函数都是<code>Function类型</code>的实例，函数名实际上是一个指向函数对象的指针，操作函数，最重要的是操作函数的属性和方法；<code>prototype</code>：保存着所有的实例方法；其是不可以枚举的，不能使用for  in循环</p>
</blockquote>
<h4 id="没有重载-重点"><a href="#没有重载-重点" class="headerlink" title="没有重载 重点"></a>没有重载 <strong>重点</strong></h4><blockquote>
<p>重载：让类以统一的方式处理不同类型数据的一种手段。重载<code>Overloading</code>是一个类中多态性的一种表现。方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不相同。</p>
</blockquote>
<ul>
<li><p>函数声明和函数表达式 </p>
<blockquote>
<p>解析器在向执行环境中加载数据的时候，会先读取函数声明（函数变量提升），并使其在执行任何代码之前都可以访问，等到解析器真正要执行函数所在的代码行的时候，才会执行函数表达式</p>
</blockquote>
<figure class="highlight scilab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alert(<span class="built_in">sum</span>(<span class="number">10</span>,<span class="number">10</span>))</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sun</span><span class="params">(num1,num2)</span>&#123;</span></div><div class="line">       <span class="keyword">return</span> num1+num2  <span class="comment">// 把函数的声明放在执行环境顶部，但是我们使用函数表达式的时候，就会出现错误，不会函数变量提升</span></div><div class="line"> &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>函数内部属性</p>
<ul>
<li><code>arguments</code><ul>
<li>类数组对象，包含传入函数中的所有参数，主要是用来保存函数参数的</li>
<li>还有一个<code>callee属性</code>，是一个指针，指向拥有<code>arguments</code>对象的函数</li>
</ul>
</li>
</ul>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">    // 阶乘函数</span></div><div class="line">    function factoriai(num)&#123;</div><div class="line">      if(num&lt;=1)&#123;</div><div class="line">     return 1;</div><div class="line">      &#125;else&#123;</div><div class="line">         return num*arguments.callee(num-1);  // num*facoriai(num-1)</div><div class="line">       &#125;</div><div class="line">     &#125;   </div><div class="line">  ```   </div><div class="line">  </div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line">好处是在于：不需要知道函数的名字就可以完成递归调用，降低函数体内的代码与函数名的耦合度</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  -<span class="ruby"> <span class="string">`this`</span></span></div><div class="line">     -<span class="ruby"> 函数执行的环境对象</span></div><div class="line">     -<span class="ruby"> 全局函数，指向<span class="string">`window`</span>；谁调用函数就指向谁</span></div><div class="line">     </div><div class="line">  -<span class="ruby"> 函数中的非继承的方法：<span class="string">`apply(),call()`</span></span></div><div class="line">     -<span class="ruby"> 设置函数体内的<span class="string">`this`</span>对象的值</span></div><div class="line">     -<span class="ruby"> <span class="string">`apply()`</span></span></div><div class="line">         -<span class="ruby"> 参数：运行函数的作用域（必须传入），参数数组（arguments对象或者Array实例）</span></div><div class="line">     -<span class="ruby"> <span class="string">`call()`</span></span></div><div class="line">         -<span class="ruby">  参数：运行函数的作用域（必须传入），参数必须逐个列举出来</span></div><div class="line"> </div><div class="line">  -<span class="ruby"> 这两种方法没有什么不同，就是取决你给函数传递的参数的方式，真正的作用是扩充函数运行的作用域，对象不需要与方法有任何的耦合关系。</span></div></pre></td></tr></table></figure>
<pre><code>window.color=&apos;red&apos;;
var o={color:&apos;blue&apos;}
function sayColor(){
   alert(this.color)
}
sayColor();  // red
sayColor.call(this);  // red
sayColor.call(o);  // blue    
</code></pre> <figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="clean">- `bind()`</span></div><div class="line">   - 创建一个函数的实例，其`this`值会绑定到传给`bind()`函数的值。</div><div class="line">   - 即使在全局作用域调用这个函数，函数里面的`this`也是指向绑定的函数的`this`</div></pre></td></tr></table></figure>
<p>   window.color=’red’;<br>   var o={color:’blue’}<br>   function sayColor(){</p>
<pre><code>alert(this.color)
</code></pre><p>   }</p>
<pre><code>var objectS=sayColor.bind(o);
</code></pre><p>   objectS();  // blue  全局调用也是执行o对象中的this<br>```</p>
</li>
</ul>
<h3 id="基本包装类"><a href="#基本包装类" class="headerlink" title="基本包装类"></a>基本包装类</h3><ul>
<li><code>Boolean</code></li>
<li><code>Number</code></li>
<li><code>String</code></li>
<li>映射到同名的基本类型</li>
</ul>
<h3 id="单体内置对象"><a href="#单体内置对象" class="headerlink" title="单体内置对象"></a>单体内置对象</h3><ul>
<li><p><code>URL编码方法</code></p>
<ul>
<li><code>encodeURI()</code>：整个url，空格换成了<code>%20</code>  对应的<code>decodeURI()</code></li>
<li><code>encodeURIComponent()</code>：url中的某一段</li>
</ul>
</li>
<li><p><code>eval()</code></p>
<ul>
<li>一个完整的解析器</li>
<li>参数：一个；要<code>执行</code>的字符串</li>
</ul>
</li>
</ul>
<div id="music163player"><br><br>  <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=22453837&auto=1&height=66"></iframe><br></div>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[告别秋千]]></title>
      <url>/%E5%91%8A%E5%88%AB%E7%A7%8B%E5%8D%83.html</url>
      <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/1811036-5c11bf8da7b55777.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="秋千"></p>
<blockquote class="blockquote-center"><br><br>我们习惯了沉湎于回忆，却忘了自己也在一点一点变旧。沾染尘埃，锈迹了生活。<br><br>听很多的歌，像吸食大量的鸦片。<br><br>震耳欲聋，乐此不疲。<br><br>耳膜在享受着肆虐的快感。心 ，却是寂寂的，不发一语。<br><br>暮色四拢的时候，总有飞机飞过。信号灯明灭着呼啸而去。<br><br>有人沉默的远去了，有人正急切的赶赴一场相聚。<br><br>高空上演绎着起伏的悲欢。<br><br>而我，能做的不过是紧了紧书包。<br><br>转身，面无表情。<br><br>心中沟壑千条，那些人那些事早已不复原貌。<br><br>只是这旧日的影子仍旧在徘徊着，鲜活的不似曾经。<br><br>东风摇百草，四顾何茫茫。<br><br>我是如此怀念亲爱的你们，以及一不小心就不见了的自己。<br><br>那时候烂漫无知的笑啊，胸无城府的小算计呀，傻里傻气的故弄清高。<br><br>沉醉了自己，撞进了谁人的眼里。<br><br>那些扬花三月般的时光，连同无知岁月里的欢笑、泪水。<br><br>就这样，一路跑着，留一串未明的歌谣，面容模糊的远去了。<br><br>当所有的悲伤逆袭而来，我连自嘲的勇气都没有。<br><br>于是，快乐的时候不再快乐，悲伤的时候仍旧悲伤。<br><br>青春，终究是一个人的过场。<br><br>一路丢盔弃甲，一路溃不成军。<br><br>成长，本就如人饮水，冷暖自知。<br><br>亦如人情，本就凉薄。<br><br>全身而退，到底是一种奢求。<br><br>——致面容模糊的过去<br><br><br><br><br><br></blockquote>

<div id="music163player"><br>  <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=22453837&auto=1&height=66"></iframe><br></div>
]]></content>
      
        
        <tags>
            
            <tag> 杂七杂八 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
